<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="robots" content="noindex">
<title>Tinnitus Freq Finder (Multi-Layer)</title>
<style>
  :root { --bg:#0f1115; --panel:#171a21; --text:#e6e7e9; --muted:#a9b0bc; --accent:#6ee7ff; --accent2:#8a7bff; --warn:#ffb86b; --danger:#ff6b6b; }
  *{ box-sizing:border-box; }
  html,body{ height:100%; margin:0; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--text); }
  .wrap{ max-width:1100px; margin:24px auto 80px; padding:0 16px; }
  .header{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px; }
  h1{ font-size:26px; margin:0; letter-spacing:0.3px; background: linear-gradient(90deg,var(--accent),var(--accent2)); -webkit-background-clip: text; background-clip: text; color: transparent; }
  .card{ background:var(--panel); border:1px solid #222630; border-radius:16px; padding:16px; margin:14px 0; box-shadow:0 8px 30px rgba(0,0,0,.3); }
  .grid{ display:grid; grid-template-columns: repeat(12, 1fr); gap:14px; }
  .col-12{ grid-column: span 12; }
  .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  label{ font-size:13px; color:var(--muted); }
  input[type="range"]{ width:240px; }
  input[type="number"], select{ width:120px; padding:6px 8px; border-radius:10px; border:1px solid #2a2f3a; background:#0e1117; color:var(--text); }
  .btn{ padding:10px 14px; border-radius:12px; border:1px solid #2a2f3a; background:#0f1320; color:var(--text); cursor:pointer; transition:all .15s; }
  .btn.primary{ background:linear-gradient(135deg,#1b5cff,#21b6ff); border-color:transparent; }
  .btn.warn{ background:linear-gradient(135deg,#ff9f1a,#ff5f6d); border-color:transparent; }
  .btn.tab{ background:linear-gradient(135deg,#1a2030,#101726); border-color:#2f3850; color:#d9f3ff; }
  .btn.tab.active{ background:linear-gradient(135deg,#1b5cff,#21b6ff); color:#0b1020; border-color:transparent; box-shadow:0 10px 24px rgba(33,182,255,.35); }
  .badge{ padding:4px 8px; border-radius:999px; font-size:12px; background:#11161f; border:1px solid #2a2f3a; color:var(--muted); }
  .small{ font-size:12px; color:var(--muted); }
  .hr{ height:1px; background:#232733; margin:12px 0; border-radius:1px; }
  .hidden{ display:none; }
  .led{ width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:8px; background:#24303d; border:1px solid #35465a; box-shadow: inset 0 0 6px rgba(0,0,0,.4); }
  .led.green{ background:#2be38a; box-shadow:0 0 12px rgba(43,227,138,.45); }
  .led.yellow{ background:#ffd166; box-shadow:0 0 12px rgba(255,209,102,.35); }
  .led.red{ background:#ff6b6b; box-shadow:0 0 12px rgba(255,107,107,.35); }
  .toast{ padding:8px 12px; border-radius:10px; border:1px solid #3a2a2a; background:#1a1212; color:#ffb4b4; font-size:12px; }
  .layer-h{ display:flex; align-items:center; gap:10px; margin:2px 0 8px; }
  .layer-h h4{ margin:0; font-size:15px; }

  /* Layer-specific accents */
  .layer1 { --layer-accent:#4ade80; } /* green */
  .layer2 { --layer-accent:#60a5fa; } /* blue  */
  .layer3 { --layer-accent:#f97316; } /* orange*/

  .layer input[type="range"]{ accent-color: var(--layer-accent); }
  .layer .layer-h input[type="checkbox"]{ accent-color: var(--layer-accent); }
  @supports not (accent-color: auto) {
    .layer input[type="range"]{
      -webkit-appearance:none; appearance:none; height:6px; background:#2a2f3a; border-radius:8px;
    }
    .layer input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none; width:16px;height:16px;border-radius:50%;
      background:var(--layer-accent); border:2px solid #0e1117; cursor:pointer;
    }
    .layer input[type="range"]::-moz-range-thumb{
      width:16px;height:16px;border-radius:50%; background:var(--layer-accent);
      border:2px solid #0e1117; cursor:pointer;
    }
    .layer input[type="range"]::-moz-range-track{ height:6px; background:#2a2f3a; border-radius:8px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <h1>🎧 Tinnitus Freq Finder</h1>
    <div class="row">
      <div id="peakLed" class="led"></div>
      <div id="peakText" class="small">Peak OK</div>
      <div class="badge" id="todayBadge">Today: 0 min</div>
      <div class="badge" id="hfPadBadge" style="display:none">HF pad −6 dB</div>
    </div>
  </div>

  <div class="row" style="gap:8px; margin-bottom:10px">
    <button id="tabAppBtn" class="btn tab active">Freq Finder</button>
    <button id="tabGuideBtn" class="btn tab">User Guide</button>
  </div>

  <section id="tabApp" class="tabpage">
    <div class="card">
      <div class="grid">
        <div class="col-12">
          <div class="row">
            <label>Sample rate</label>
            <select id="sr" class="btn">
              <option value="48000" selected>48,000 Hz</option>
              <option value="44100">44,100 Hz</option>
            </select>
            <label>Duration (s)</label>
            <input id="duration" type="number" value="10" min="1" max="1800" step="1" />
            <span class="small">Tip: test with 10–30s; long exports are heavy.</span>
          </div>
        </div>

        <div class="col-12">
          <h3 style="margin:6px 0 8px">Multi-Layer Synth (up to 3 layers)</h3>

          <!-- LAYER 1 -->
          <div class="card layer layer1" style="padding:12px; margin:10px 0">
            <div class="layer-h">
              <input type="checkbox" id="l1_enable" checked />
              <h4>Layer 1</h4>
              <span class="small">Tone + band / cluster</span>
            </div>
            <div class="row">
              <label for="l1_freq">Frequency (Hz)</label>
              <input type="range" id="l1_freq" min="100" max="16000" step="1" value="8000" />
              <input type="number" id="l1_freqNum" min="100" max="22000" step="1" value="8000" />
              <label for="l1_bw">Bandwidth (Hz)</label>
              <input type="range" id="l1_bw" min="0" max="4000" step="10" value="400" />
              <input type="number" id="l1_bwNum" min="0" max="20000" step="10" value="400" />
            </div>
            <div class="row">
              <label for="l1_toneMix">Tone mix</label>
              <input type="range" id="l1_toneMix" min="0" max="1" step="0.01" value="0.6" />
              <input type="number" id="l1_toneMixNum" min="0" max="1" step="0.01" value="0.6" />
              <label for="l1_noiseMix">Noise mix</label>
              <input type="range" id="l1_noiseMix" min="0" max="1" step="0.01" value="0.4" />
              <input type="number" id="l1_noiseMixNum" min="0" max="1" step="0.01" value="0.4" />
              <label for="l1_level">Level</label>
              <input type="range" id="l1_level" min="0" max="1" step="0.01" value="1" />
              <input type="number" id="l1_levelNum" min="0" max="1" step="0.01" value="1" />
            </div>
            <div class="row">
              <label for="l1_color">Noise color</label>
              <select id="l1_color">
                <option value="white" selected>White</option>
                <option value="pink">Pink</option>
                <option value="brown">Brown</option>
              </select>
              <label for="l1_texture">Texture</label>
              <select id="l1_texture">
                <option value="noise" selected>Noise</option>
                <option value="smooth">Smooth hiss</option>
                <option value="hum">Hum</option>
              </select>
              <label for="l1_amHz">AM rate (Hz)</label>
              <input type="range" id="l1_amHz" min="0" max="40" step="0.1" value="0" />
              <input type="number" id="l1_amHzNum" min="0" max="40" step="0.1" value="0" />
              <label for="l1_amDepth">AM depth</label>
              <input type="range" id="l1_amDepth" min="0" max="1" step="0.01" value="0" />
              <input type="number" id="l1_amDepthNum" min="0" max="1" step="0.01" value="0" />
            </div>
          </div>

          <!-- LAYER 2 -->
          <div class="card layer layer2" style="padding:12px; margin:10px 0">
            <div class="layer-h">
              <input type="checkbox" id="l2_enable" />
              <h4>Layer 2</h4>
              <span class="small">Optional 2nd band</span>
            </div>
            <div class="row">
              <label for="l2_freq">Frequency (Hz)</label>
              <input type="range" id="l2_freq" min="100" max="16000" step="1" value="6000" />
              <input type="number" id="l2_freqNum" min="100" max="22000" step="1" value="6000" />
              <label for="l2_bw">Bandwidth (Hz)</label>
              <input type="range" id="l2_bw" min="0" max="4000" step="10" value="1200" />
              <input type="number" id="l2_bwNum" min="0" max="20000" step="10" value="1200" />
            </div>
            <div class="row">
              <label for="l2_toneMix">Tone mix</label>
              <input type="range" id="l2_toneMix" min="0" max="1" step="0.01" value="0.2" />
              <input type="number" id="l2_toneMixNum" min="0" max="1" step="0.01" value="0.2" />
              <label for="l2_noiseMix">Noise mix</label>
              <input type="range" id="l2_noiseMix" min="0" max="1" step="0.01" value="0.8" />
              <input type="number" id="l2_noiseMixNum" min="0" max="1" step="0.01" value="0.8" />
              <label for="l2_level">Level</label>
              <input type="range" id="l2_level" min="0" max="1" step="0.01" value="0.6" />
              <input type="number" id="l2_levelNum" min="0" max="1" step="0.01" value="0.6" />
            </div>
            <div class="row">
              <label for="l2_color">Noise color</label>
              <select id="l2_color">
                <option value="white">White</option>
                <option value="pink" selected>Pink</option>
                <option value="brown">Brown</option>
              </select>
              <label for="l2_texture">Texture</label>
              <select id="l2_texture">
                <option value="noise" selected>Noise</option>
                <option value="smooth">Smooth hiss</option>
                <option value="hum">Hum</option>
              </select>
              <label for="l2_amHz">AM rate (Hz)</label>
              <input type="range" id="l2_amHz" min="0" max="40" step="0.1" value="0" />
              <input type="number" id="l2_amHzNum" min="0" max="40" step="0.1" value="0" />
              <label for="l2_amDepth">AM depth</label>
              <input type="range" id="l2_amDepth" min="0" max="1" step="0.01" value="0" />
              <input type="number" id="l2_amDepthNum" min="0" max="1" step="0.01" value="0" />
            </div>
          </div>

          <!-- LAYER 3 -->
          <div class="card layer layer3" style="padding:12px; margin:10px 0">
            <div class="layer-h">
              <input type="checkbox" id="l3_enable" />
              <h4>Layer 3</h4>
              <span class="small">Optional 3rd band</span>
            </div>
            <div class="row">
              <label for="l3_freq">Frequency (Hz)</label>
              <input type="range" id="l3_freq" min="100" max="16000" step="1" value="3000" />
              <input type="number" id="l3_freqNum" min="100" max="22000" step="1" value="3000" />
              <label for="l3_bw">Bandwidth (Hz)</label>
              <input type="range" id="l3_bw" min="0" max="4000" step="10" value="2000" />
              <input type="number" id="l3_bwNum" min="0" max="20000" step="10" value="2000" />
            </div>
            <div class="row">
              <label for="l3_toneMix">Tone mix</label>
              <input type="range" id="l3_toneMix" min="0" max="1" step="0.01" value="0.0" />
              <input type="number" id="l3_toneMixNum" min="0" max="1" step="0.01" value="0.0" />
              <label for="l3_noiseMix">Noise mix</label>
              <input type="range" id="l3_noiseMix" min="0" max="1" step="0.01" value="1.0" />
              <input type="number" id="l3_noiseMixNum" min="0" max="1" step="0.01" value="1.0" />
              <label for="l3_level">Level</label>
              <input type="range" id="l3_level" min="0" max="1" step="0.01" value="0.4" />
              <input type="number" id="l3_levelNum" min="0" max="1" step="0.01" value="0.4" />
            </div>
            <div class="row">
              <label for="l3_color">Noise color</label>
              <select id="l3_color">
                <option value="white">White</option>
                <option value="pink">Pink</option>
                <option value="brown" selected>Brown</option>
              </select>
              <label for="l3_texture">Texture</label>
              <select id="l3_texture">
                <option value="noise" selected>Noise</option>
                <option value="smooth">Smooth hiss</option>
                <option value="hum">Hum</option>
              </select>
              <label for="l3_amHz">AM rate (Hz)</label>
              <input type="range" id="l3_amHz" min="0" max="40" step="0.1" value="0" />
              <input type="number" id="l3_amHzNum" min="0" max="40" step="0.1" value="0" />
              <label for="l3_amDepth">AM depth</label>
              <input type="range" id="l3_amDepth" min="0" max="1" step="0.01" value="0" />
              <input type="number" id="l3_amDepthNum" min="0" max="1" step="0.01" value="0" />
            </div>
          </div>
        </div>

        <!-- GLOBAL -->
        <div class="col-12">
          <h3 style="margin:6px 0 8px">Global Muffle, Gating & Safety</h3>
          <div class="row">
            <label for="mufFc">Muffle cutoff (Hz)</label>
            <input type="range" id="mufFc" min="0" max="24000" step="50" value="6500" />
            <input type="number" id="mufFcNum" min="0" max="24000" step="10" value="6500" />
            <span class="small">0 = off</span>
            <label for="mufOrder">Muffle order</label>
            <input type="range" id="mufOrder" min="1" max="6" step="1" value="2" />
            <input type="number" id="mufOrderNum" min="1" max="8" step="1" value="2" />
          </div>
          <div class="row">
            <label for="onMs">Slice ON (ms)</label>
            <input type="range" id="onMs" min="0" max="20" step="1" value="0" />
            <input type="number" id="onMsNum" min="0" max="200" step="1" value="0" />
            <label for="offMs">Slice OFF (ms)</label>
            <input type="range" id="offMs" min="0" max="40" step="1" value="0" />
            <input type="number" id="offMsNum" min="0" max="500" step="1" value="0" />
            <span class="small">(Set ON &gt; 0 to enable; OFF can be 0)</span>
            <div id="hpWarn" class="toast hidden">Headphones only recommended when slicing is active.</div>
          </div>
          <div class="row">
            <label for="outDb">Output level</label>
            <input type="range" id="outDb" min="-24" max="-6" step="1" value="-12" />
            <input type="number" id="outDbNum" min="-24" max="-6" step="1" value="-12" />
            <span class="small">dB (capped)</span>
            <label for="route">Routing</label>
            <select id="route" class="btn">
              <option value="stereo" selected>Stereo</option>
              <option value="left">Left-only</option>
              <option value="right">Right-only</option>
            </select>
            <label class="row" style="gap:6px">
              <input type="checkbox" id="hfOverride" />
              <span class="small">Disable HF pad &gt;10 kHz</span>
            </label>
          </div>
          <div class="row small" style="opacity:.85">
            <span class="badge">Shift+Drag</span> for fine control • Live update for layer <b>Freq</b>, <b>BW</b>, <b>Mix/Level</b>, <b>AM</b>, <b>Muffle cutoff</b>, <b>Output</b>. Changes to <b>Texture</b>, <b>Slice</b>, <b>Muffle order</b>, <b>Duration</b> apply on next start.
          </div>
        </div>

        <div class="col-12">
          <div class="row" style="margin-top:10px">
            <button id="playToggleBtn" class="btn primary">▶︎ Play / Monitor</button>
            <div class="hr" style="flex:1"></div>
            <button id="exportBtn" class="btn">⬇︎ Export WAV</button>
            <span class="small">Files include settings in the filename.</span>
          </div>
        </div>

      </div>
    </div>

    <div class="card">
      <h3 style="margin:6px 0 8px">Notes</h3>
      <ul class="small">
        <li><b>Texture</b>: “Noise” = classic filtered noise (grainy); “Smooth hiss” = many micro-sines (fine, steady); “Hum” = few detuned sines (soft, tonal).</li>
        <li>Change <b>Texture</b> then press <b>Stop → Play</b> to rebuild the source (the switch also autostops/plays now).</li>
      </ul>
    </div>
  </section>

  <section id="tabGuide" class="tabpage hidden">
    <div class="card">
      <h2>User Guide</h2>
      <p class="small">Guide unchanged—focus here is the new Texture switch.</p>
    </div>
  </section>
</div>

<script>
(function(){
  'use strict';

  // -------- DOM helpers --------
  const $ = (id) => document.getElementById(id);

  // Tabs
  const tabAppBtn = $('tabAppBtn');
  const tabGuideBtn = $('tabGuideBtn');
  const tabApp = $('tabApp');
  const tabGuide = $('tabGuide');
  function showTab(which){ const app = which==='app'; tabApp.classList.toggle('hidden',!app); tabGuide.classList.toggle('hidden',app); tabAppBtn.classList.toggle('active',app); tabGuideBtn.classList.toggle('active',!app); }
  tabAppBtn.addEventListener('click',()=>showTab('app'));
  tabGuideBtn.addEventListener('click',()=>showTab('guide'));

  // Header bits
  const peakLed = $('peakLed');
  const peakText = $('peakText');
  const todayBadge = $('todayBadge');
  const hfPadBadge = $('hfPadBadge');
  const hpWarn = $('hpWarn');

  // Controls
  const sr = $('sr'), duration = $('duration'),
        mufFc = $('mufFc'), mufFcNum = $('mufFcNum'),
        mufOrder = $('mufOrder'), mufOrderNum = $('mufOrderNum'),
        onMs = $('onMs'), onMsNum = $('onMsNum'),
        offMs = $('offMs'), offMsNum = $('offMsNum'),
        outDb = $('outDb'), outDbNum = $('outDbNum'),
        route = $('route'), hfOverride = $('hfOverride'),
        playToggleBtn = $('playToggleBtn'), exportBtn = $('exportBtn');

  const lin=(db)=>Math.pow(10,db/20);
  const clamp=(v,lo,hi)=>Math.min(hi,Math.max(lo,v));

  function todayKey(){ const d=new Date(); return d.toISOString().slice(0,10); }
  function getTodayMinutes(){ const key='minutes_'+todayKey(); return +(localStorage.getItem(key)||'0'); }
  function addTodayMinutes(min){ const key='minutes_'+todayKey(); const cur=getTodayMinutes(); localStorage.setItem(key,String(cur+min)); renderToday(); }
  function renderToday(){ todayBadge.textContent = `Today: ${getTodayMinutes().toFixed(1)} min`; }
  renderToday();

  // Layer DOM bundles
  function layerDom(i){
    return {
      enable: $('l'+i+'_enable'),
      freq: $('l'+i+'_freq'),
      freqNum: $('l'+i+'_freqNum'),
      bw: $('l'+i+'_bw'),
      bwNum: $('l'+i+'_bwNum'),
      toneMix: $('l'+i+'_toneMix'),
      toneMixNum: $('l'+i+'_toneMixNum'),
      noiseMix: $('l'+i+'_noiseMix'),
      noiseMixNum: $('l'+i+'_noiseMixNum'),
      level: $('l'+i+'_level'),
      levelNum: $('l'+i+'_levelNum'),
      color: $('l'+i+'_color'),
      texture: $('l'+i+'_texture'),
      amHz: $('l'+i+'_amHz'),
      amHzNum: $('l'+i+'_amHzNum'),
      amDepth: $('l'+i+'_amDepth'),
      amDepthNum: $('l'+i+'_amDepthNum')
    };
  }
  const L=[layerDom(1),layerDom(2),layerDom(3)];

  // Link helpers
  function linkPair(rangeEl,numEl,{min=null,max=null}={}){
    const sync=(src,dst)=>{ dst.value=src.value; };
    rangeEl.addEventListener('input',()=>{ sync(rangeEl,numEl); scheduleApply(); });
    numEl.addEventListener('input',()=>{
      if(min!==null) numEl.value=Math.max(min,+numEl.value);
      if(max!==null) numEl.value=Math.min(max,+numEl.value);
      sync(numEl,rangeEl); scheduleApply();
    });
    sync(rangeEl,numEl);
  }
  function bindTypingFreq(layer){
    const MIN=100, MAX=22000;
    layer.freq.addEventListener('input',()=>{ layer.freqNum.value=layer.freq.value; scheduleApply(); });
    layer.freqNum.addEventListener('input',()=>{
      const v=parseFloat(layer.freqNum.value);
      if(Number.isFinite(v)&&v>=MIN&&v<=MAX){ layer.freq.value=String(v); scheduleApply(); }
    });
    const commit=()=>{
      let v=parseFloat(layer.freqNum.value); if(!Number.isFinite(v)) v=+layer.freq.value||8000;
      v=clamp(v,MIN,MAX); layer.freqNum.value=String(v); layer.freq.value=String(v); scheduleApply();
    };
    layer.freqNum.addEventListener('change',commit);
    layer.freqNum.addEventListener('blur',commit);
    layer.freqNum.addEventListener('keydown',e=>{ if(e.key==='Enter'){ commit(); layer.freqNum.blur(); } });
    layer.freqNum.value=layer.freq.value;
  }

  L.forEach(layer=>{
    bindTypingFreq(layer);
    linkPair(layer.bw,layer.bwNum,{min:0,max:20000});
    linkPair(layer.toneMix,layer.toneMixNum,{min:0,max:1});
    linkPair(layer.noiseMix,layer.noiseMixNum,{min:0,max:1});
    linkPair(layer.level,layer.levelNum,{min:0,max:1});
    linkPair(layer.amHz,layer.amHzNum,{min:0,max:40});
    linkPair(layer.amDepth,layer.amDepthNum,{min:0,max:1});
    layer.color.addEventListener('change',scheduleApply);
    layer.texture.addEventListener('change', async ()=>{ if(liveCtx){ await stop(); await play(); } }); // rebuild graph
    layer.enable.addEventListener('change',scheduleApply);
  });

  // Global binds
  (function linkMuf(){
    const MIN=0, MAX=24000;
    mufFc.addEventListener('input',()=>{ mufFcNum.value=mufFc.value; scheduleApply(); });
    const commit=()=>{
      let v=parseFloat(mufFcNum.value); if(!Number.isFinite(v)) v=6500;
      v=clamp(v,MIN,MAX); mufFcNum.value=String(v); mufFc.value=String(v); scheduleApply();
    };
    mufFcNum.addEventListener('change',commit);
    mufFcNum.addEventListener('blur',commit);
    mufFcNum.addEventListener('keydown',e=>{ if(e.key==='Enter'){ commit(); mufFcNum.blur(); } });
    mufFcNum.value=mufFc.value;
  })();
  linkPair(mufOrder,mufOrderNum,{min:1,max:8});
  onMs.addEventListener('input',()=>{ onMsNum.value=onMs.value; });
  onMsNum.addEventListener('input',()=>{ onMs.value=onMsNum.value; });
  offMs.addEventListener('input',()=>{ offMsNum.value=offMs.value; });
  offMsNum.addEventListener('input',()=>{ offMs.value=offMsNum.value; });
  linkPair(outDb,outDbNum,{min:-24,max:-6});
  route.addEventListener('change',scheduleApply);
  hfOverride.addEventListener('change',scheduleApply);

  function getParams(){
    const layers=L.map(layer=>{
      const t=+layer.toneMixNum.value, n=+layer.noiseMixNum.value; const s=Math.max(1e-9,t+n);
      return {
        enable:layer.enable.checked,
        freq:Math.max(100,+layer.freqNum.value),
        bw:Math.max(0,+layer.bwNum.value),
        toneMix:t/s, noiseMix:n/s,
        level:clamp(+layer.levelNum.value,0,1),
        color:layer.color.value,
        texture:layer.texture.value,
        amHz:Math.max(0,+layer.amHzNum.value),
        amDepth:clamp(+layer.amDepthNum.value,0,1)
      };
    });
    const anyHigh=layers.some(l=>l.enable&&l.freq>10000);
    const hfPadActive=anyHigh&&!hfOverride.checked;
    hfPadBadge.style.display=hfPadActive?'inline-block':'none';
    hpWarn.classList.toggle('hidden', !(+onMsNum.value>0));
    return {
      sr:+sr.value, duration:Math.max(0.1,+duration.value),
      layers,
      mufFc:Math.max(0,+mufFcNum.value),
      mufOrder:Math.max(1,Math.round(+mufOrderNum.value)),
      onMs:Math.max(0,+onMsNum.value), offMs:Math.max(0,+offMsNum.value),
      outDb:Math.min(-6,Math.max(-24,+outDbNum.value)),
      route:route.value, hfPad:hfPadActive?0.5:1.0
    };
  }

  // ---------- Audio graph helpers ----------
  function noiseBuffer(ctx, seconds=8){
    const buf=ctx.createBuffer(1,Math.max(1,Math.floor(ctx.sampleRate*seconds)),ctx.sampleRate);
    const d=buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; return buf;
  }
  function colorNode(ctx,color){
    if(color==='white'){ return new GainNode(ctx,{gain:1}); }
    if(color==='pink'){ return new BiquadFilterNode(ctx,{type:'lowshelf',frequency:1000,gain:-9}); }
    return new BiquadFilterNode(ctx,{type:'lowpass',frequency:1000,Q:0.707}); // brown
  }
  function buildCluster(ctx,f0,bw,K){
    const group=new GainNode(ctx,{gain:1});
    const partials=[];
    for(let k=0;k<K;k++){
      const pos=(K===1)?0:(-1 + 2*k/(K-1));     // -1..1
      const delta=(bw/2)*pos;
      const weight=Math.exp(-2.5*pos*pos);      // gaussian-ish
      const osc=new OscillatorNode(ctx,{type:'sine',frequency:f0+delta});
      const g=new GainNode(ctx,{gain:0});       // will set below
      osc.connect(g).connect(group); osc.start();
      partials.push({osc,gain:g,pos,weight});
    }
    // normalize weights
    const sumW=partials.reduce((s,p)=>s+p.weight,0);
    partials.forEach(p=>{ p.weight/=sumW; });
    return {group,partials};
  }

  // ---------- buildGraph (this is the one you were missing) ----------
  function buildGraph(ctx,p,forOffline=false){
    const preMuffleMix=new GainNode(ctx,{gain:1});
    const layerNodes=[]; const baseNoise=noiseBuffer(ctx,8);

    for(let i=0;i<p.layers.length;i++){
      const Lp=p.layers[i];
      // Tone
      const osc=new OscillatorNode(ctx,{type:'sine',frequency:Lp.freq});
      const toneGain=new GainNode(ctx,{gain: Lp.enable?(Lp.level*Lp.toneMix):0});
      osc.connect(toneGain);

      // Texture branch: classic noise or cluster (smooth/hum)
      let noise=null,color=null,bp=null, noiseGain;
      let cluster=null; let texture=Lp.texture;
      noiseGain=new GainNode(ctx,{gain: Lp.enable?(Lp.level*Lp.noiseMix):0});

      if(texture==='noise'){
        noise=new AudioBufferSourceNode(ctx,{buffer:baseNoise,loop:true});
        color=colorNode(ctx,Lp.color);
        const q=Math.max(0.0001, Lp.bw>0 ? (Lp.freq/Math.max(1,Lp.bw)) : 0.0001);
        bp=new BiquadFilterNode(ctx,{type:'bandpass',frequency:Lp.freq,Q:q});
        noise.connect(color).connect(bp).connect(noiseGain);
        noise.start();
      }else{
        const K=(texture==='hum')?6:24;
        cluster=buildCluster(ctx, Lp.freq, Math.max(1,Lp.bw||1), K);
        // Make cluster audible immediately (partials carry shape; noiseGain sets loudness)
        const bwInit = Math.max(1, Lp.bw || 1);
        for (const prt of cluster.partials) {
          prt.osc.frequency.value = Lp.freq + prt.pos * (bwInit/2);
          prt.gain.gain.value     = prt.weight;   // non-zero
        }
        cluster.group.connect(noiseGain);
      }

      // Sum tone + (noise/cluster)
      const layerSum=new GainNode(ctx,{gain:1});
      toneGain.connect(layerSum); noiseGain.connect(layerSum);

      // AM
      const amGain=new GainNode(ctx,{gain:1});
      layerSum.connect(amGain);
      const depth=Lp.amDepth||0;
      const amScale=new GainNode(ctx,{gain:depth/2});
      const amOffset=new ConstantSourceNode(ctx,{offset:1 - depth/2});
      amOffset.connect(amGain.gain); amOffset.start();
      const amOsc=new OscillatorNode(ctx,{type:'sine',frequency:Math.max(0.0001, Lp.amHz||0.0001)});
      amOsc.connect(amScale).connect(amGain.gain); amOsc.start();

      amGain.connect(preMuffleMix);
      osc.start();

      layerNodes.push({osc,toneGain,noise,color,bp,noiseGain,layerSum,amGain,amOsc,amScale,amOffset, texture, cluster});
    }

    // Global muffle
    let chainHead=preMuffleMix; const lpChain=[];
    if(p.mufFc>0){
      for(let i=0;i<p.mufOrder;i++){
        const lp=new BiquadFilterNode(ctx,{type:'lowpass',frequency:p.mufFc,Q:0.707});
        chainHead.connect(lp); chainHead=lp; lpChain.push(lp);
      }
    }

    // Global slicing gate
    const gate=new GainNode(ctx,{gain:1.0});
    chainHead.connect(gate);
    function scheduleGate(){
      if(p.onMs<=0){ gate.gain.setValueAtTime(1.0,0); return; }
      const on=p.onMs/1000, off=p.offMs/1000, period=Math.max(1e-4,on+off);
      const total=p.duration; let t=0; gate.gain.cancelScheduledValues(0);
      while(t<total){ gate.gain.setValueAtTime(1.0,t); const tOff=t+on; if(tOff<=total){ gate.gain.setValueAtTime(0.0,tOff); } t+=period; }
    }

    // Master + limiter
    const master=new GainNode(ctx,{gain:0.0});
    const limiter=new DynamicsCompressorNode(ctx,{threshold:-6,knee:30,ratio:20,attack:0.003,release:0.25});
    gate.connect(master).connect(limiter);

    // Routing
    let routeNodes=null;
    if(forOffline){ limiter.connect(ctx.destination); }
    else{
      const leftGain=new GainNode(ctx,{gain:1});
      const rightGain=new GainNode(ctx,{gain:1});
      const merger=new ChannelMergerNode(ctx,{numberOfInputs:2});
      limiter.connect(leftGain); limiter.connect(rightGain);
      leftGain.connect(merger,0,0); rightGain.connect(merger,0,1);
      merger.connect(ctx.destination);
      routeNodes={leftGain,rightGain};
    }

    function setMasterTarget(db,pad){ master.gain.setTargetAtTime(Math.max(0, lin(db)*pad), ctx.currentTime, 0.03); }
    function start(at=0){ scheduleGate(); setMasterTarget(p.outDb,p.hfPad); master.gain.setValueAtTime(0.0,at); master.gain.linearRampToValueAtTime(Math.max(0,lin(p.outDb)*p.hfPad), at+0.3); }
    function stop(at){
      try{
        master.gain.cancelScheduledValues(at); master.gain.linearRampToValueAtTime(0.0, at+0.3);
        for(const ln of layerNodes){
          try{ ln.osc.stop(at+0.35); }catch(_){}
          if(ln.noise){ try{ ln.noise.stop(at+0.35); }catch(_){ } }
          if(ln.cluster && ln.cluster.partials){ for(const prt of ln.cluster.partials){ try{ prt.osc.stop(at+0.35); }catch(_){} } }
        }
      }catch(_){}
    }

    return { start, stop, nodes:{layerNodes,lpChain,gate,master,limiter,routeNodes} };
  }

  // ---------- Live playback ----------
  let liveCtx=null, liveCtrl=null, liveNodes=null, liveStopTimer=null, peakProcessor=null, sessionStart=null, tickTimer=null;

  function setRoute(which){ if(!liveNodes||!liveNodes.routeNodes) return;
    if(which==='left'){ liveNodes.routeNodes.leftGain.gain.value=1; liveNodes.routeNodes.rightGain.gain.value=0; }
    else if(which==='right'){ liveNodes.routeNodes.leftGain.gain.value=0; liveNodes.routeNodes.rightGain.gain.value=1; }
    else { liveNodes.routeNodes.leftGain.gain.value=1; liveNodes.routeNodes.rightGain.gain.value=1; }
  }
  function updatePeakUI(level){
    const dbfs=20*Math.log10(Math.max(level,1e-9));
    peakText.textContent=`Peak ${dbfs.toFixed(1)} dBFS`;
    peakLed.classList.remove('green','yellow','red');
    if(level<0.5) peakLed.classList.add('green'); else if(level<0.89) peakLed.classList.add('yellow'); else peakLed.classList.add('red');
  }
  function attachPeakProcessor(ctx,sourceNode){
    const proc=ctx.createScriptProcessor(2048,1,1);
    sourceNode.connect(proc); proc.connect(ctx.destination);
    proc.onaudioprocess=(e)=>{
      const ch=e.inputBuffer.getChannelData(0); let peak=0; for(let i=0;i<ch.length;i++){ const a=Math.abs(ch[i]); if(a>peak) peak=a; }
      updatePeakUI(peak);
      if(peak>=0.89){ const curDb=+outDbNum.value; const newDb=Math.max(-24,curDb-3); if(newDb<curDb){ outDbNum.value=String(newDb); outDb.value=outDbNum.value; applyLiveParams(); } }
    };
    return proc;
  }
  function updatePlayButton(playing){
    const btn=playToggleBtn;
    if(playing){ btn.textContent='■ Stop'; btn.classList.remove('primary'); btn.classList.add('warn'); }
    else { btn.textContent='▶︎ Play / Monitor'; btn.classList.remove('warn'); btn.classList.add('primary'); }
  }

  async function play(){
    if(liveCtx){ await stop(); }
    const p=getParams();
    liveCtx=new (window.AudioContext||window.webkitAudioContext)({sampleRate:p.sr});
    liveCtrl=buildGraph(liveCtx,p);
    liveNodes=liveCtrl.nodes; setRoute(p.route);
    peakProcessor=attachPeakProcessor(liveCtx, liveNodes.limiter);
    liveCtrl.start(liveCtx.currentTime);
    updatePlayButton(true);
    sessionStart=performance.now();
    clearTimeout(liveStopTimer); clearInterval(tickTimer);
    liveStopTimer=setTimeout(()=>{ stop(); }, p.duration*1000+120);
    tickTimer=setInterval(()=>{ renderToday(); }, 5000);
  }
  async function stop(){
    if(!liveCtx) return;
    try{ const t=liveCtx.currentTime; liveCtrl?.stop(t); }catch(_){}
    await new Promise(r=>setTimeout(r,380));
    try{ peakProcessor?.disconnect(); }catch(_){}
    try{ liveCtx.close(); }catch(_){}
    if(sessionStart){ const mins=(performance.now()-sessionStart)/60000; if(mins>0){ addTodayMinutes(mins); } }
    liveCtx=null; liveCtrl=null; liveNodes=null; peakProcessor=null; sessionStart=null;
    clearTimeout(liveStopTimer); clearInterval(tickTimer);
    updatePlayButton(false);
  }
  async function togglePlay(){ if(liveCtx){ await stop(); } else { await play(); } }
  playToggleBtn.addEventListener('click',togglePlay);
  document.addEventListener('keydown',e=>{ if(e.code==='Space'||e.code==='Escape'){ e.preventDefault(); stop(); } });

  // Live param updates
  function applyLiveParams(){
    if(!liveCtx||!liveNodes) return; const p=getParams();
    try{
      for(let i=0;i<liveNodes.layerNodes.length;i++){
        const N=liveNodes.layerNodes[i]; const Lp=p.layers[i];
        // Tone
        N.osc.frequency.setTargetAtTime(Lp.freq, liveCtx.currentTime, 0.01);
        N.toneGain.gain.setTargetAtTime(Lp.enable?(Lp.level*Lp.toneMix):0, liveCtx.currentTime, 0.02);

        // Texture branch
        if(N.texture==='noise'){
          if(N.bp){
            N.bp.frequency.setTargetAtTime(Lp.freq, liveCtx.currentTime, 0.01);
            const q=Math.max(0.0001, Lp.bw>0 ? (Lp.freq/Math.max(1,Lp.bw)) : 0.0001);
            N.bp.Q.setTargetAtTime(q, liveCtx.currentTime, 0.01);
          }
          if(N.color){
            if(N.color.type==='lowshelf'){ N.color.gain.setTargetAtTime((Lp.color==='pink')?-9:(Lp.color==='brown'?-15:0), liveCtx.currentTime, 0.02); }
            if(N.color.type==='lowpass'){ N.color.frequency.setTargetAtTime((Lp.color==='brown')?1000:20000, liveCtx.currentTime, 0.02); }
          }
        } else if (N.cluster && N.cluster.partials){
          const bw = Math.max(1, Lp.bw||1);
          for (const prt of N.cluster.partials) {
            const f = Lp.freq + prt.pos*(bw/2);
            prt.osc.frequency.setTargetAtTime(f, liveCtx.currentTime, 0.01);
            prt.gain.gain.setTargetAtTime(prt.weight, liveCtx.currentTime, 0.02); // weight only
          }
        }

        // Overall “noise/cluster” loudness here (single place)
        N.noiseGain.gain.setTargetAtTime(Lp.enable?(Lp.level*Lp.noiseMix):0, liveCtx.currentTime, 0.02);

        // AM
        const depth=Lp.amDepth||0;
        N.amScale.gain.setTargetAtTime(depth/2, liveCtx.currentTime, 0.02);
        N.amOffset.offset.setTargetAtTime(1 - depth/2, liveCtx.currentTime, 0.02);
        N.amOsc.frequency.setTargetAtTime(Math.max(0.0001,Lp.amHz||0.0001), liveCtx.currentTime, 0.02);
      }
      if(liveNodes.lpChain && liveNodes.lpChain.length){
        for(const lp of liveNodes.lpChain){ lp.frequency.setTargetAtTime(Math.max(20, p.mufFc||20000), liveCtx.currentTime, 0.02); }
      }
      const target=Math.max(0, lin(p.outDb)*p.hfPad);
      liveNodes.master.gain.setTargetAtTime(target, liveCtx.currentTime, 0.03);
      setRoute(p.route);
    }catch(_){}
  }
  let rafPending=false; function scheduleApply(){ if(!liveCtx) return; if(rafPending) return; rafPending=true; requestAnimationFrame(()=>{ rafPending=false; applyLiveParams(); }); }
  [mufFc,mufFcNum,outDb,outDbNum,route,hfOverride].forEach(el=>el.addEventListener('input',scheduleApply));
  ;[onMs,onMsNum,mufOrder,mufOrderNum,duration].forEach(el=>el.addEventListener('input',()=>{}));

  // ---------- Export ----------
  function floatToWavBlob(chData,sr){
    const numFrames=chData.length; const buffer=new ArrayBuffer(44+numFrames*2); const view=new DataView(buffer);
    const WS=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); };
    WS(0,'RIFF'); view.setUint32(4,36+numFrames*2,true); WS(8,'WAVE'); WS(12,'fmt '); view.setUint32(16,16,true);
    view.setUint16(20,1,true); view.setUint16(22,1,true); view.setUint32(24,sr,true); view.setUint32(28,sr*2,true);
    view.setUint16(32,2,true); view.setUint16(34,16,true); WS(36,'data'); view.setUint32(40,numFrames*2,true);
    let off=44; for(let i=0;i<numFrames;i++){ const s=Math.max(-1,Math.min(1,chData[i]*0.98)); view.setInt16(off, s<0 ? s*0x8000 : s*0x7FFF, true); off+=2; }
    return new Blob([view],{type:'audio/wav'});
  }
  async function exportWav(){
    const p0=getParams();
    if(p0.duration>1800){ alert('Please keep duration ≤ 1800s (30 min).'); return; }
    const offCtx=new OfflineAudioContext(1, Math.ceil(p0.sr*p0.duration), p0.sr);
    const ctrl=buildGraph(offCtx,p0,true); ctrl.start(0);
    const rendered=await offCtx.startRendering();
    const ch=rendered.getChannelData(0);
    let peak=0; for(let i=0;i<ch.length;i++){ const a=Math.abs(ch[i]); if(a>peak) peak=a; }
    if(peak>0.98){ alert('Export peaked too high; lowering output 3 dB and retry.'); outDbNum.value=String(Math.max(-24,+outDbNum.value-3)); outDb.value=outDbNum.value; return exportWav(); }
    const blob=floatToWavBlob(ch,p0.sr);
    function layerTag(Lp,idx){
      if(!Lp.enable) return `L${idx}off`;
      return `L${idx}f${Math.round(Lp.freq)}bw${Math.round(Lp.bw)}t${Lp.toneMix.toFixed(2)}n${Lp.noiseMix.toFixed(2)}lvl${Lp.level.toFixed(2)}_${Lp.color}_${Lp.texture}_am${(+Lp.amHz).toFixed(1)}x${(+Lp.amDepth).toFixed(2)}`;
    }
    const layersPart=p0.layers.map((Lx,i)=>layerTag(Lx,i+1)).join('__');
    const tag=`${layersPart}_muf${Math.round(p0.mufFc)}o${p0.mufOrder}_slice${Math.round(p0.onMs)}x${Math.round(p0.offMs)}_${p0.duration}s_${p0.sr}sr_out${p0.outDb}dB${p0.hfPad<1?'_HFpad':''}`;
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`tinnitus_${tag}.wav`; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),5000);
  }
  exportBtn.addEventListener('click',exportWav);
})();
</script>
</body>
</html>
