<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Winning Edge</title>
  <style>
 /* ==========  Global layout / colours  ========== */
body{
    font-family:Arial,Helvetica,sans-serif;
    padding:10px;
    background: #086d22;
    color:lightgreen;
}
.container{display:flex;height:100vh}

/* ---------- buttons ---------- */
button{
    margin:12px;
    padding:9px 9px;
    background: salmon;
    color:#fff;
    border:none;
    cursor:pointer;
    font-size:16px;
    border-radius:4px;
}
button:hover{background:slategray}

/* ---------- inputs ---------- */
input[type="number"],
input[type="text"]{
    width:40px;
    text-align:center;
    font-size:16px;
    margin:2px;
    background:#fffbcc;
}

/* ---------- top-numbers input strip ---------- */
#top18Inputs { display: none; }

/* ---------- table styling ---------- */
table{
    border-collapse:collapse;
    margin-top:10px;
    width:100%;
    background:#000;
}
th,td{
    border:1px solid #666;
    width:30px;height:30px;
    text-align:center;
    color:lightgray;
}
th{background:#333;color:#fff}

.selected-top-skip{background:#ff0!important;color:#000;font-weight:bold}
.top18-selected   {background:orange!important;color:#000;font-weight:bold}
.missed-over-25   {background:red!important;color:#fff;font-weight:bold}
.red-dot,.orange-dot{
    width:14px;height:14px;border-radius:50%;margin:auto
}
.red-dot   {background:red}
.orange-dot{background:orange}
table tr:hover{background:#444}

#skipFrequencyContainer td{font-size:17px}
#newDrawingInputs{margin-left:12px}

/* ==========  Modal  ========== */
.modal{
    display:none;position:fixed;z-index:1;left:0;top:0;width:100%;height:100%;
    overflow:auto;background:rgba(0,0,0,.4);
}
.modal-content {
    background: black;
    color: lightgreen;
    padding: 20px;
    border: 1px solid #888;
    width: 70%;
    max-width: 480px;
    max-height: 80vh;
    overflow-y: auto;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}

.close-button {
  position: absolute;
  top: 12px;
  right: 16px;
  font-size: 28px;
  font-weight: bold;
  color: lightgray;
  cursor: pointer;
}
.close-button:hover { color: white; }

/* ---------- modal footer ---------- */
.modal-footer{
    margin:18px 0 8px;display:flex;gap:16px;justify-content:center
}

/* ==========  Powerball picker block  ========== */
#load1Button{display:none}

#pbBlock{
    display:none;
    gap:6px;margin:12px 0 8px 12px;
    align-items:center
}
#pbBlock input{ width:36px;background:#fffbcc }

/* ==========  Items hidden until data have loaded  ========== */
#newDrawingInputs,
#top18Inputs,
button[onclick="exportGeneratedSets()"],
button[onclick="exportBestSets()"],
button[onclick="updateReverseHitsTop18()"] {
  display: none;
}
#newDrawingInputs > button { display: none; }

button img{
    width:150px;height:auto;display:block;pointer-events:none;
}
button:hover img{ filter:brightness(1.15); }
button.active{
    outline:3px solid gold;
    outline-offset:2px;
    filter:brightness(1.25);
}

/* ---------- image buttons ---------- */
.gameBtn{
    background:#000;
    padding:10px;
    border:none;
    cursor:pointer;
    border-radius:6px;
    margin:12px;
}
.gameBtn:hover img{filter:brightness(1.2);}
.gameBtn.active{
    outline:3px solid gold;
    outline-offset:2px;
    filter:brightness(1.25);
}

/* keep the old style for any other text buttons */
button:not(.gameBtn){ background:#064d06; }

input.dimmed { opacity: 0.4; pointer-events: none; }

#top18Inputs > div { display: inline-block; }

#matchResults div { margin: 4px 0; font-weight: bold; }

/* Remove spinner arrows */
input[type=number]::-webkit-inner-spin-button,
input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
input[type=number]{ -moz-appearance: textfield; }

/* 🎯 Scoped Button Styles */
.button { font-size:100%; padding:6px 12px; margin:5px; border:none; border-radius:5px; cursor:pointer; transition:all .2s ease; background:#444; color:#fff!important; }
.button:hover { opacity:.8; }
.button-single { background: salmon; color:black; }
.button-purple { background: purple; color:#fff; }

h1 {
  font-family: 'Comic Sans MS', cursive;
  font-style: italic;
  font-size: 54px;
  text-align: center;
  position: relative;
  margin: auto;
  width: auto;
  color: gold;
}

/* ---------- headings ---------- */
h2{margin:0 0 8px;color: lightgreen}
h3{margin:0 0 15px;color: gold}

.bar-entry { display:flex; align-items:center; margin:4px 0; font-family:monospace; font-size:14px; }
.bar-label { width:80px; color:gold; text-align:right; padding-right:6px; }
.bar { height:14px; background:lightgreen; margin-left:4px; }

#splashScreen {
  position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
  background: green; z-index: 9999; display:flex; flex-direction:column; align-items:center; justify-content:center;
}
#splashImage { max-width: 90%; max-height: 80vh; }
#splashText { margin-top: 20px; color: gold; font-size: 32px; font-weight: bold; font-family: 'Comic Sans MS', cursive; }

.green-dot{ width:14px;height:14px;border-radius:50%;margin:auto;background:#32cd32; }
.hot-dot{ width:14px;height:14px;border-radius:50%;margin:auto;background:#00bfff; }

/* Toast */
#tweToast {
  position: fixed;
  left: 50%;
  top: 50%;                      /* move from bottom to middle */
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,.85);
  color: #fff;
  padding: 18px 26px;            /* more padding */
  border-radius: 8px;
  font-size: 22px;               /* larger font */
  font-weight: bold;
  z-index: 99999;
  opacity: 0;
  pointer-events: none;
  transition: opacity .3s ease, transform .3s ease;
}
#tweToast.show {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1.05); /* subtle "pop" */
}

  </style>
</head>
<body>

<div id="splashScreen">
  <div style="text-align: center; margin-top: 40px; margin-bottom: 30px;">
    <h1 style="font-family: 'Comic Sans MS', cursive; font-style: italic; font-size: 64px; color: gold; margin-bottom: 12px; text-shadow: 2px 2px 4px black;">
      The Winning Edge
    </h1>
    <div style="font-size: 24px; color: lime; font-family: 'Arial', sans-serif; font-weight: 300; text-shadow: 1px 1px 2px #000;">
      Statistically Optimized Lotto Picks
      <br><br><br>
    </div>
  </div>

  <div id="splashText">Loading your luck...</div><br><br>
  <img src="potogold.gif" alt="Loading your luck..." id="splashImage">
</div>

<!-- Title again after splash -->
<div style="text-align: center; margin-top: 40px; margin-bottom: 30px;">
  <h1 style="font-family: 'Comic Sans MS', cursive; font-style: italic; font-size: 64px; color: gold; margin-bottom: 12px; text-shadow: 2px 2px 4px black;">
    The Winning Edge
  </h1>
  <div style="font-size: 24px; color: lime; font-family: 'Arial', sans-serif; font-weight: 300; text-shadow: 1px 1px 2px #000;">
    Statistically Optimized Lotto Picks
  </div>
</div>

<br>
<h2>Load a Lotto Dataset</h2>

<button id="powerball" class="gameBtn">
    <img src="powerball.png" alt="Load 69-number game">
</button>

<button id="load1Button" class="gameBtn">
    <img src="power.png" alt="Load PB-only game">
</button>

<button id="load39Button" class="gameBtn">
    <img src="Fantasy5.png" alt="Load 39-number game">
</button>

<span id="lastDrawingDisplay" style="font-weight: bold; margin-left: 30px; font-size: 24px;">
  <span style="color: gold;">Last Drawing #:</span>
  <span id="lastDrawingNumber" style="color: lightyellow;">–</span>
</span>

<div id="pbBlock">
    <h3 style="margin:0 6px 0 0;">Pick Powerball Number</h3>
    <input><input><input><input><input>
</div>
<br>

<button id="methodologyBtn" class="button button-single">📘 Methodology</button>
<button id="showHistogramBtn" class="button button-single" style="display:none;">📊 Show Points Histogram</button>
<button id="checkNumbersButton" class="button button-single" style="margin-left: 10px;">✅ Check Numbers</button>
<br><br>

<h2 id="top18Label">Your Picks (Editable)</h2>

<div id="top18Inputs"></div>
<button id="updateHitsBtn" class="button button-single">🔄 Update Picks Column</button>
<button id="loadTop18Button" class="button button-single">📂 Load Prior Picks</button>
<button id="systemPicksButton" class="button button-single" style="display:none">🤖 System Picks</button>
<button id="savePicksBtn" class="button button-single">💾 Save Picks</button><br>

<div id="loadTop18Modal" class="modal">
  <div class="modal-content">
    <span class="close-button" id="closeLoadModal">&times;</span>
    <h2>Load Prior Picks</h2>
    <input type="file" id="loadTop18FileInput">
  </div>
</div>

<button id="autoPickTopBtn" class="button button-single">🧠 Find Hot Numbers</button>
<button id="generateWheelButton" class="button button-purple" style="display:none">🎯 Generate Wheel</button>
<button id="quick12Button" class="button button-single" style="display:none">⚡ 12-Number Quick</button>

<br><br>

<div id="wheelModal" class="modal">
  <div class="modal-content">
    <span class="close-button close-wheel">&times;</span>
    <h2>Generated Wheel Sets</h2>

    <div id="progressInfo" style="margin-top:6px;font-size:14px;"></div>
    <div id="modalWheelOutput" style="white-space:pre-wrap"></div>

    <div style="margin-top:10px">
      <label style="color:lightgreen">How many sets to generate? </label>
      <input type="number" id="modalSetCountChoice" value="6" min="1" max="100" style="width:50px;font-size:16px;background:#333;color:#fff"><br>
      <label style="color:lightgreen">Show Best Sets: </label>
      <input type="number" id="modalBestSetCount" value="5" min="1" style="width:50px;font-size:16px;background:#333;color:#fff">
    </div>

    <div class="modal-footer">
      <button id="generateSetsModalButton">🎯 Generate Sets</button>
      <button id="pickBestSetsModal">✨ Pick Best</button>
      <button id="exportAllBtn">⬇️ Export All</button>
      <button id="exportBestBtn">⬇️ Export Best</button>
    </div>
  </div>
</div>

<div id="wheelOutput" style="display: none;"></div>

<div id="hitsTableSection" style="display: none;">
    <h2>Hits Table (Last 25 Drawings)</h2>
    <div id="latestDrawingComment" style="margin-bottom: 10px; font-weight: bold;"></div>
    <div id="recentDrawsContainer"></div>
</div>

<div id="methodologyModal" class="modal">
<div class="modal-content">
  <span class="close-button" id="closeMethodology">&times;</span>
  <h2>How This Works</h2>

  <h3 style="margin-top:16px;">Skips (orange dots)</h3>
  <p style="line-height:1.6;">
    <b>Skips</b> are based on each number’s “time since last hit” and the
    <i>historical frequency</i> of that exact skip length. Numbers whose current skip length
    lines up with a historically common skip for that number are considered stronger (more “due”).
  </p>

  <h3 style="margin-top:16px;">Hot (blue dots)</h3>
  <p style="line-height:1.6;">
    <b>Hot</b> looks at just the last 25 drawings and scores numbers by recent activity:
    more weight on newer hits, a small bonus if hits are accelerating, and a minimum of recent presence.
    This favors numbers trending now, not just historically.
  </p>

  <h3 style="margin-top:16px;">Picks (green dots)</h3>
  <p style="line-height:1.6;">
    <b>Picks</b> blend <b>Skips</b> + <b>Hot</b> + “due” (time since hit), then refine the pool to reduce
    clumping and lower the average <b>Points</b> (see below). We start with the overlap of Hot∩Skips,
    ensure at least half are from Skips, add remaining from Hot, and backfill from recent frequency if needed.
    Finally, we run a quick points-aware swap search to improve spacing and reduce weak patterns.
  </p>
  <ul style="line-height:1.6; margin-left:18px;">
    <li><b>Spacing:</b> small penalty if a candidate sits right next to something already picked.</li>
    <li><b>Due-ness:</b> longer “since last hit” helps a candidate.</li>
    <li><b>Deterministic:</b> the System Picks button uses a stable seed based on the current dataset and latest draw.
        Same data in ⇒ same picks out.</li>
  </ul>

  <h3 style="margin-top:16px;">Wheel Generation</h3>
  <p style="line-height:1.6;">
    When you open <b>Generate Wheel</b>, we build 5-number sets from <i>your 12 inputs</i> (not the Skips/Hot columns).
    Each set must pass filters:
  </p>
  <ul style="line-height:1.6; margin-left:18px;">
    <li><b>Sum window:</b> reject sets whose sum is too low/high vs what’s typical for your 12-number pool.</li>
    <li><b>No recent full draw:</b> reject sets that exactly match any recent 5-number draw.</li>
    <li><b>Points cap:</b> reject sets whose Points score is above a threshold (we want stronger shapes).</li>
    <li><b>Coverage:</b> we track 3-number combinations covered; more sets ⇒ more 3-combo coverage.</li>
  </ul>

  <h3 style="margin-top:16px;">Points (shape/quality score)</h3>
  <p style="line-height:1.6;">
    <b>Points</b> evaluate a 5-number set’s “shape.” Lower is better. We reference empirical tables to
    penalize unusual or historically weak patterns. Features include:
  </p>
  <ul style="line-height:1.6; margin-left:18px;">
    <li><b>Sum</b> &amp; <b>Spread</b></li>
    <li><b>Odd–Even balance</b> &amp; <b>Low–High balance</b></li>
    <li><b>Consecutive pairs</b> and gaps between positions (1–2, 2–3, 3–4, 4–5)</li>
    <li>Min/Max and center value</li>
  </ul>
  <p style="line-height:1.6;">
    Picks try to minimize average Points across many sampled combinations from the pool, which tends to
    avoid awkward clumps, skewed parity, and odd spreads.
  </p>

  <h3 style="margin-top:16px;">Does this improve my odds?</h3>
  <p style="line-height:1.6;">
    The jackpot odds don’t change, but this workflow aims to improve your chances of matching 3–4 numbers by:
  </p>
  <ul style="line-height:1.6; margin-left:18px;">
    <li>Selecting numbers with statistically supportive signals (Skips + Hot + Due)</li>
    <li>Favoring balanced “shapes” via the Points score</li>
    <li>Filtering out obviously weak sets and near-duplicates of recent full draws</li>
    <li>Covering more distinct 3-number combos with fewer tickets</li>
  </ul>
  <p style="line-height:1.6; color: #ddd;">
    It’s not magic—just disciplined filtering, scoring, and coverage.
  </p>
</div>

</div>

<h2>Hits Table</h2> 
<h3>Last 25 Drawings</h3>
<div id="reverseHitsContainer"></div>
<br>
<h2>Skip Frequency Table</h2>
<h3>Number of Drawings Between Hits</h3>
<div id="skipFrequencyContainer"></div>

<!-- ✅ Check Winning Numbers Modal -->
<div id="checkNumbersModal" class="modal">
  <div class="modal-content" style="width: 60%; max-width: none;">
    <span class="close-button close-check">&times;</span>
    <h2>Check Your Numbers</h2>
    <br>
    <div style="display: flex; gap: 40px;">
      <!-- Left Side: Prize Table -->
      <div style="flex: 1;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
          <label style="font-size: 20px; font-weight: bold; color: orange;">Prize Table</label>
          <div id="drawNumberLabel" style="color: lightyellow; font-size: 18px;"></div>
        </div>
        <table id="prizeTable" style="width: 100%; border-collapse: collapse; color: lightgreen;">
          <thead><tr><th>Match Tier</th><th>Winners</th><th>Prize</th></tr></thead>
          <tbody></tbody>
        </table>
        <br><br>
      </div>

      <!-- Left Side: Winning Numbers + Match Results -->
      <div style="flex: 1;">
        <div id="checkInputFields">
          <label style="font-size: 20px; font-weight: bold; color: orange;">Winning Numbers:</label><br>
          <div style="display: flex; align-items: center; gap: 10px; margin-top: 6px;">
            <div id="winningNumbersDisplay" style="display: flex; gap: 10px; font-size: 20px; color: gold;"></div>
            <div id="winningPBDisplay" style="font-size: 20px; color: gold;"></div>
          </div>
        </div>
        <br>
        <div id="matchResults" style="margin-top: 10px; font-weight: bold;"></div>
      </div>
    </div>
  </div>
</div>

<!-- 🔳 Scrolling Histogram Modal -->
<div id="histogramModal" class="modal">
  <div class="modal-content" style="max-width: 700px; width: 90%; max-height: 80vh; overflow-y: auto; position: relative;">
    <span id="closeHistogramModal" class="close-button" style="top: 10px; right: 14px;">&times;</span>
    <h2 style="margin-top: 0; color: lightgreen;">Points Per Drawing (Latest on Top)</h2>
    <div id="histogramContent"></div>
  </div>
</div>

<div id="autoPickModal" class="modal">
  <div class="modal-content" style="width: 400px; max-width: 90%;">
    <span class="close-button" id="closeAutoPickModal">&times;</span>
    <h2>Find Hot Numbers</h2>
    
    <label for="weeksInput">Number of Drawings (max 25):</label>
    <input type="number" id="weeksInput" min="1" max="25" value="25" style="width:60px"><br><br>

    <label>Select Coverage:</label><br>
    <input type="radio" name="coverage" value="5" id="coverage5">
    <label for="coverage5">Top 5</label><br>
    <input type="radio" name="coverage" value="12" id="coverage12">
    <label for="coverage12">Top 12</label><br>
    <input type="radio" name="coverage" value="18" id="coverage18" checked>
    <label for="coverage18">Top 18</label><br><br>
    <button id="runAutoPick" class="button button-purple">🎯 Generate</button>
    <button id="saveTop18Button" class="button button-single" style="display:none;">💾 Save Top #'s</button>
    <button id="exportAutoTopBtn" class="button button-single" style="display:none;">⬇️ Export Auto Top</button>
  </div>
</div>

<script>
let systemPicks = new Set();
let latestDrawingNumber = null;
let fullData = [];
let top18 = [];
let pastDrawings = [];
let totalNumbersGlobal = 39, generatedSets=[];
let skipDataGlobal={}, sinceMap={}, referenceData={};
let top18From69 = [];
let fullDataFrom69 = [], skipDataGlobalFrom69 = {}, sinceMapFrom69 = {}, pastDrawingsFrom69 = [];
let activeGameMode = null;

const qs  = sel => document.querySelector(sel);
const qsa = sel => Array.from(document.querySelectorAll(sel));

/* ── BUTTON VISIBILITY / ELEMENTS ── */
const btn39 = qs('#load39Button'),
      btn69 = qs('#powerball'),
      btn1  = qs('#load1Button'),
      pbBlk = qs('#pbBlock');

const wheelModal = document.getElementById('wheelModal');
let skipDataFrom69 = {};

/* ── Button handlers for loading datasets ── */
btn69.onclick = () => {
  loadCSVFile('lotto_69.txt', 69, () => {
    activeGameMode = 69;

    // Keep inputs manual and exactly 12 (placeholders)
    ensureTwelveInputs();

    // Auto-fill Top (orange), Hot (blue), Picks (green) — all 12 — deterministically
    populateAllThreeOnLoad();

    // ---- existing UI/show logic (unchanged) ----
    // Save supporting data for restoring later
    pastDrawingsFrom69 = [...pastDrawings];
    skipDataFrom69     = JSON.parse(JSON.stringify(skipDataGlobal));
    sinceMapFrom69     = { ...sinceMap };
    fullDataFrom69     = [...fullData];

    if (btn1) btn1.style.display = 'inline-block';

    hidePBblock();
    qs('#generateWheelButton').style.display = 'inline-block';
    qs('#quick12Button').style.display       = 'inline-block';
    qs('#systemPicksButton').style.display   = 'inline-block';
    qs('#checkNumbersButton').style.display  = 'inline-block';
    document.getElementById('showHistogramBtn').style.display = 'inline-block';
    setupHistogramListener();
    highlight(btn69);

    // Show Top inputs/controls (inputs remain for your manual edits)
    document.getElementById('top18Inputs').style.display = 'flex';
    const label = document.getElementById('top18Label'); if (label) label.style.display = 'block';
    ['updateHitsBtn','autoPickTopBtn','saveTop18Button','loadTop18Button'].forEach(id => {
      const el = document.getElementById(id); if (el) el.style.display = 'inline-block';
    });

    const pbSpan = document.getElementById('checkPBSpan');
    if (pbSpan) pbSpan.style.display = 'inline';
  });
};


btn1.onclick = () => {
  highlight(btn1);
  totalNumbersGlobal = 26;
  activeGameMode = 26;

  showPBblock();
  qs('#generateWheelButton').style.display = 'none';
  qs('#checkNumbersButton').style.display = 'none';
  document.getElementById('showHistogramBtn').style.display = 'none';
  qs('#quick12Button').style.display = 'none';
  qs('#systemPicksButton').style.display = 'none';

  const checkPBSpan = document.getElementById('checkPBSpan');
  if (checkPBSpan) checkPBSpan.style.display = 'none';

  // hide Top controls
  ['top18Inputs','updateHitsBtn','autoPickTopBtn','saveTop18Button','loadTop18Button','top18Label'].forEach(id=>{
    const el=document.getElementById(id); if(el) el.style.display='none';
  });

  // load 1-number data
  loadCSVFile('lotto_1.txt', 26, () => {
    const highlighted = [];
    for (let number = 1; number <= totalNumbersGlobal; number++) {
      const val = skipDataGlobal.skipTable[number]?.reduce((a, b) => a + b, 0) || 0;
      highlighted.push({ number, val });
    }
    highlighted.sort((a, b) => b.val - a.val);
    top18 = highlighted.slice(0, 12).map(x => x.number).sort((a, b) => a - b);

    const top18InputsDiv = document.getElementById('top18Inputs');
    top18InputsDiv.innerHTML = '';
    for (let i = 0; i < top18.length; i++) {
      const inp = document.createElement('input');
      inp.type = 'text';
      inp.value = top18[i];
      top18InputsDiv.appendChild(inp);
    }

    updateReverseHitsTop18();
    rehighlightSkipTableFromTop18();
  });
};

btn39.onclick = () => {
  loadCSVFile('lotto_39.txt', 39, () => {
    activeGameMode = 39;

    // Keep inputs manual and exactly 12 (placeholders)
    ensureTwelveInputs();

    // Auto-fill Top (orange), Hot (blue), Picks (green) — all 12 — deterministically
    populateAllThreeOnLoad();

    // ---- existing UI/show logic (unchanged) ----
    if (btn1) btn1.style.display = 'none';
    hidePBblock();
    highlight(btn39);
    qs('#generateWheelButton').style.display = 'inline-block';
    qs('#quick12Button').style.display       = 'inline-block';
    qs('#systemPicksButton').style.display   = 'inline-block';
    qs('#checkNumbersButton').style.display  = 'inline-block';
    document.getElementById('showHistogramBtn').style.display = 'inline-block';
    setupHistogramListener();

    document.getElementById('top18Inputs').style.display = 'flex';
    const label = document.getElementById('top18Label'); if (label) label.style.display = 'block';
    ['updateHitsBtn','autoPickTopBtn','saveTop18Button','loadTop18Button'].forEach(id => {
      const el = document.getElementById(id); if (el) el.style.display = 'inline-block';
    });

    const checkPBSpan = document.getElementById('checkPBSpan');
    if (checkPBSpan) checkPBSpan.style.display = 'none';
  });
};

/* Save/Load Top18 */
const saveTop18Button = document.getElementById('saveTop18Button');
const loadTop18Button = document.getElementById('loadTop18Button');
const loadTop18Modal = document.getElementById('loadTop18Modal');
const loadTop18FileInput = document.getElementById('loadTop18FileInput');
const closeLoadModal = document.getElementById('closeLoadModal');
const savePicksBtn = document.getElementById('savePicksBtn');
if (savePicksBtn) savePicksBtn.addEventListener('click', savePicksFromInputs);

// Save the 12 inputs (low→high) to a file
function savePicksFromInputs() {
  const nums = Array.from(document.querySelectorAll('#top18Inputs input'))
    .slice(0, 12)
    .map(inp => parseInt(inp.value.trim(), 10))
    .filter(n => Number.isInteger(n));

  if (nums.length !== 12) {
    alert('Please enter 12 valid numbers in the input boxes before saving.');
    return;
  }

  const sorted = nums.sort((a,b)=>a-b);

  // Use both the current drawing and the next one
  const currentDraw = (typeof latestDrawingNumber === 'number' && !isNaN(latestDrawingNumber))
    ? String(latestDrawingNumber) : '00000';
  const nextDraw = (typeof latestDrawingNumber === 'number' && !isNaN(latestDrawingNumber))
    ? String(latestDrawingNumber + 1) : '00000';

  const prefix = (totalNumbersGlobal === 69) ? 'picksPB'
               : (totalNumbersGlobal === 39) ? 'picksF5'
               : 'picks';

  // Filename example: picksPB_cur1469_next1470.txt
  const filename = `${prefix}_cur${currentDraw}_next${nextDraw}.txt`;

  const blob = new Blob([sorted.join(', ')], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  setTimeout(() => URL.revokeObjectURL(a.href), 100);
}

saveTop18Button.addEventListener('click', saveTop18Numbers);
loadTop18Button.addEventListener('click', () => { loadTop18Modal.style.display = 'block'; });
closeLoadModal.addEventListener('click', () => { loadTop18Modal.style.display = 'none'; });
loadTop18FileInput.addEventListener('change', handleTop18FileSelect);

/* Methodology modal */
document.getElementById('methodologyBtn').addEventListener('click', () => {
  document.getElementById('methodologyModal').style.display = 'block';
});
document.getElementById('closeMethodology').addEventListener('click', () => {
  document.getElementById('methodologyModal').style.display = 'none';
});
window.addEventListener('click', (event) => {
  if (event.target.id === 'methodologyModal') {
    document.getElementById('methodologyModal').style.display = 'none';
  }
});

/* Export Auto Top (hidden button) */
window.onload = function () {
  const exportBtn = document.getElementById('exportAutoTopBtn');
  if (exportBtn) {
    exportBtn.addEventListener('click', () => {
      const weeks = document.getElementById('weeksInput').value || '00';
      const coverage = document.querySelector('input[name="coverage"]:checked')?.value || '00';
      const nextDraw = (typeof latestDrawingNumber === 'number') ? latestDrawingNumber + 1 : '00000';
      const prefix = (totalNumbersGlobal === 69) ? 'auto_topPB' :
                     (totalNumbersGlobal === 39) ? 'auto_topF5' : 'auto_topX';

      const inputs = Array.from(document.querySelectorAll('#top18Inputs input'));
      const numbers = inputs.map(inp => parseInt(inp.value.trim(), 10)).filter(n => !isNaN(n));
      const sorted = numbers.sort((a, b) => a - b);
      const content = sorted.join(', ');

      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${prefix}_${weeks}_${coverage}_${nextDraw}.txt`;
      document.body.appendChild(link);
      link.click();
      setTimeout(() => { URL.revokeObjectURL(url); link.remove(); document.getElementById('autoPickModal').style.display = 'none'; }, 100);
    });
  }
};

document.addEventListener('DOMContentLoaded', () => {
  const closeAutoBtn = document.getElementById('closeAutoPickModal');
  if (closeAutoBtn) closeAutoBtn.addEventListener('click', () => { document.getElementById('autoPickModal').style.display = 'none'; });

  const runAutoBtn = document.getElementById('runAutoPick');
  if (runAutoBtn) {
runAutoBtn.addEventListener('click', () => {
  const weeks = Math.min(25, Math.max(1, parseInt(document.getElementById('weeksInput').value, 10) || 25));
  const count = parseInt(document.querySelector('input[name="coverage"]:checked').value, 10);

  // Recalculate Hot (blue dots)
  const beforeHot = new Set(hotSet);
  const hotNums = computeTrendingHotNumbers(weeks, count);
  hotSet = new Set(hotNums);

  // 👉 Also recompute Picks (green dots)
  const beforePicks = new Set(systemPicksSet);
  setDeterministicSeed('systemPicks');
  const picks = computeSystemPicks(12, weeks, hotNums, top18, sinceMap);
  systemPicksSet = new Set(picks);
  setInputsFromList(picks, 12);   // mirror into inputs

  // Redraw
  renderReverseHitsTable();
  reapplySkipTableHighlights();

  // Feedback
  const hotChanged   = !setsEqual(beforeHot, hotSet);
  const picksChanged = !setsEqual(beforePicks, systemPicksSet);
  if (hotChanged || picksChanged) {
    showToast('Hot + Picks updated.');
  } else {
    showToast('Recalculated (no change).');
  }
});

  }

  // Open Auto-pick modal
  const showAutoBtn = document.getElementById('autoPickTopBtn');
  if (showAutoBtn) {
    showAutoBtn.addEventListener('click', () => {
      document.getElementById('saveTop18Button').style.display = 'none';
      document.getElementById('autoPickModal').style.display = 'block';
    });
  }

  // ✅ Attach System Picks button once
  const sysBtn = document.getElementById('systemPicksButton');
  if (sysBtn) sysBtn.addEventListener('click', runSystemPicks);
});

// Holds current System Picks result
let systemPicksSet = new Set();
let hotSet = new Set();

function syncPicksToHot() {
  systemPicksSet = new Set(hotSet);
  renderReverseHitsTable();
}

function getTopSkipsFromInputs(limit = 12) {
  const nums = Array.from(document.querySelectorAll('#top18Inputs input'))
    .map(inp => parseInt(inp.value.trim(), 10))
    .filter(n => !isNaN(n));
  return nums.slice(0, limit).sort((a,b)=>a-b);
}

function computeTopHitsFromRecent(weeks = 25, count = 12) {
  if (!fullData || !fullData.length) return [];
  const recentDraws = fullData.slice(0, Math.min(weeks, fullData.length))
    .map(row => row.slice(1).map(Number));

  const freq = {};
  recentDraws.forEach(draw => draw.forEach(n => { if (!isNaN(n)) freq[n] = (freq[n] || 0) + 1; }));

  return Object.entries(freq)
    .sort((a,b)=> b[1]-a[1])
    .slice(0, count)
    .map(([n]) => parseInt(n,10))
    .sort((a,b)=>a-b);
}

// --- 1) If generateTopNumbersAndRender is missing, provide a simple version
if (typeof generateTopNumbersAndRender !== "function") {
  window.generateTopNumbersAndRender = function () {
    // no-op: manual 12 inputs only now
  };
}


// --- 2) Alias the missing name to your existing highlighter
if (typeof rehighlightSkipTableFromTop18 !== "function") {
  window.rehighlightSkipTableFromTop18 = function() {
    if (typeof reapplySkipTableHighlights === "function") {
      reapplySkipTableHighlights();
    }
  };
}

// --- 3) Minimal Pick Best implementation used by the modal button
if (typeof pickBestSets !== "function") {
  window.pickBestSets = function(openModal = true) {
    if (!generatedSets || !generatedSets.length) {
      alert('Generate sets first.');
      return;
    }
    const bestCountInput = document.getElementById('modalBestSetCount');
    const bestCount = parseInt(bestCountInput?.value, 10) || 5;

    const best = [...generatedSets].sort((a,b) => a.points - b.points).slice(0, bestCount);

    const out = document.getElementById('modalWheelOutput');
    let html = '<ol>';
    best.forEach(({ combo, points }) => {
      html += `<li style="color:${getColorForPoints(points)}">${combo.join(', ')} ➔ <b>${points.toFixed(1)} pts</b></li>`;
    });
    html += '</ol>';
    out.innerHTML = html;

    if (openModal) document.getElementById('wheelModal').style.display = 'block';
  };
}

// --- Seeded RNG utilities (deterministic randomness) ---
function makeRNG(seed) {
  let s = (seed >>> 0) || 1;
  return function rng() {
    s ^= s << 13; s ^= s >>> 17; s ^= s << 5;
    return ((s >>> 0) / 4294967296);
  };
}
function stableSeed(...things) {
  const str = JSON.stringify(things);
  let h = 2166136261 >>> 0;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

const asSorted = arr => [...arr].sort((a,b)=>a-b);

// --- Deterministic RNG glue ---
let __rng = Math.random;              // default: normal randomness
function rand() { return __rng(); }   // use this everywhere instead of Math.random

function setDeterministicSeed(tag = 'systemPicks') {
  // Build a stable seed from the dataset + tag so same data → same picks.
  const seed = stableSeed(
    tag,
    totalNumbersGlobal,
    latestDrawingNumber || 0,
    // include latest row content to “lock” to the dataset snapshot
    (fullData && fullData[0]) ? fullData[0].join(',') : ''
  );
  __rng = makeRNG(seed);
}


function loadCSVFile(filename, totalNumbers, callback, isPowerball69 = false) {
    fetch(filename + '?t=' + Date.now())
        .then(response => response.text())
        .then(text => {
            fullData = text.trim().split('\n').map(line => line.split(',').map(n => n.trim()));
            const drawingNumbers = fullData.map(row => parseInt(row[0]));
            latestDrawingNumber = drawingNumbers[0];

            const lastDrawElem = document.getElementById('lastDrawingNumber');
            if (lastDrawElem) {
                lastDrawElem.textContent = latestDrawingNumber || '–';
            } else {
                console.warn("⚠️ Element with ID 'lastDrawingNumber' not found.");
            }

            const data = fullData.map(row => row.slice(1).map(n => parseInt(n)))
                .filter(row => row.every(n => !isNaN(n)));

            totalNumbersGlobal = totalNumbers;
            hotSet.clear();  // ✅ reset Hot when switching datasets

            skipDataGlobal = buildSkipTable(data, totalNumbers, drawingNumbers);

            pastDrawings = fullData.filter(row => row.length >= 6)
                .map(row => row.slice(1, 6).map(n => parseInt(n)).sort((a, b) => a - b).join(','));

            renderRecentDraws(data, totalNumbers, drawingNumbers[0]);
            // ⬇️ draw Skip Frequency table now that skipDataGlobal/sinceMap are ready
renderSkipFrequency();


            const quick12Btn = document.getElementById('quick12Button');
            if (quick12Btn) quick12Btn.style.display = (totalNumbers === 26) ? 'none' : 'inline-block';

const genBtn = document.getElementById('generateWheelButton');
if (genBtn) {
  genBtn.style.display = (totalNumbers === 69 || totalNumbers === 39) ? 'inline-block' : 'none';
}


            const topInputs = document.getElementById('top18Inputs');
if (topInputs) topInputs.style.display = (totalNumbers === 26) ? 'none' : 'flex';

            const exportAllButton = document.querySelector('button[onclick="exportGeneratedSets()"]');
            if (exportAllButton) exportAllButton.style.display = 'inline-block';

            const exportBestButton = document.querySelector('button[onclick="exportBestSets()"]');
            if (exportBestButton) exportBestButton.style.display = 'inline-block';

            const updateHitsButton = document.querySelector('button[onclick="updateReverseHitsTop18()"]');
            if (updateHitsButton) updateHitsButton.style.display = 'inline-block';

            const reverseHits = document.getElementById('reverseHitsContainer');
            if (reverseHits) reverseHits.style.display = 'block';

            const skipFreq = document.getElementById('skipFrequencyContainer');
            if (skipFreq) skipFreq.style.display = 'block';

            if (typeof callback === 'function') {
                callback();
            }
        })
        .catch(error => {
            console.error('Failed to load file:', error);
            alert('Error loading the file.');
        });
}

// expose it globally so any handler can call it
window.loadCSVFile = loadCSVFile;

// Pick the `count` numbers whose current "since" length has the strongest historical frequency.
// Score = how often this number historically had the current since-length.
// Tie-breakers: larger current since (more due), then smaller number.
// Pick by how much a number "likes" its CURRENT skip length (bin), with smoothing + due nudge.
function recomputeTopFromSkips(count = 12) {
  if (!skipDataGlobal || !skipDataGlobal.skipTable || !sinceMap) return [];

  const picks = [];
  for (let n = 1; n <= totalNumbersGlobal; n++) {
    const row = skipDataGlobal.skipTable[n] || [];
    const curSkip = sinceMap[n] || 26;            // 1..25; 26+ = "over 25"
    const capped = Math.min(curSkip, 25);         // we only have bins 1..25

    // Row total for smoothing / context
    const rowTotal = row.slice(1, 26).reduce((a, b) => a + (b || 0), 0);

    // Frequency of THIS number hitting after THIS exact skip length historically
    const freqAtCur = (capped >= 1 && capped <= 25) ? (row[capped] || 0) : 0;

    // Laplace smoothing (prevents zeroes from dominating)
    const p = (freqAtCur + 1) / (rowTotal + 25);  // “probability” this number likes this bin

    // Gentle due bonus so longer-current-skips aren’t ignored when p is similar
    const dueBonus = 1 + 0.15 * Math.log1p(curSkip);  // tweak 0.10–0.25 to taste

    const score = p * dueBonus;

    picks.push({
      n,
      score,
      curSkip,
      freqAtCur,
      rowTotal
    });
  }

  // Rank by the “likes current bin” score; then favor longer current skips; then smaller number
  picks.sort((a, b) =>
    (b.score - a.score) ||
    (b.curSkip - a.curSkip) ||
     (a.n - b.n)
  );

  const top = picks.slice(0, count).map(x => x.n).sort((a,b)=>a-b);
  top18 = top;

  renderReverseHitsTable();
  reapplySkipTableHighlights();
  return top;
}



function computeTrendingHotNumbers(weeks = 25, count = 12) {
  const N = Math.min(weeks, fullData.length);
  if (!N) return [];

  // Parse the last N draws (0 = most recent)
  const windowDraws = fullData.slice(0, N)
    .map(row => row.slice(1).map(Number).filter(n => !isNaN(n)));

  const stats = Array.from({ length: totalNumbersGlobal + 1 }, () => ({
    hits: 0,
    lastAges: [],  // draw indices (0 recent) where number hit
    recencyScore: 0
  }));

  // Exponential decay for recency (tau controls decay; smaller = more recent emphasis)
  const tau = Math.max(4, Math.round(N / 3));

  windowDraws.forEach((nums, age) => {
    const w = Math.exp(-age / tau);
    nums.forEach(n => {
      if (n >= 1 && n <= totalNumbersGlobal) {
        stats[n].hits += 1;
        stats[n].recencyScore += w;
        stats[n].lastAges.push(age);
      }
    });
  });

  // Build scored entries with acceleration bonus
  const R = Math.max(1, Math.ceil(N / 3)); // "recent" slice for plain recent-count
  const entries = [];
  for (let n = 1; n <= totalNumbersGlobal; n++) {
    const s = stats[n];
    if (s.hits === 0) continue;

    // Recent-count in last R draws
    const recentCount = s.lastAges.filter(a => a < R).length;

    // Acceleration: compare last two inter-hit gaps (smaller gap = speeding up)
    // ages: e.g., [0, 4, 11] -> gaps [4-0, 11-4] = [4,7] (but ages grow going older)
    const ages = s.lastAges.slice().sort((a, b) => a - b); // youngest->oldest
    let accelBonus = 0;
    if (ages.length >= 3) {
      const lastGap = ages[1] - ages[0];      // most recent gap
      const prevGap = ages[2] - ages[1];      // prior gap
      const accel = Math.max(0, prevGap - lastGap); // positive = accelerating
      // Normalize a bit so it’s a small nudge, not the whole story:
      accelBonus = accel / Math.max(2, Math.min(12, R));
    }

    const veryRecent = ages.length && ages[0] <= 3; // hit within 3 draws
    const eligibility = (recentCount >= 2) || veryRecent;

    // Composite score: mostly recency + a touch of raw hits + acceleration nudge
    const score = (0.65 * s.recencyScore) + (0.25 * recentCount) + (0.10 * accelBonus);

    entries.push({ n, recentCount, veryRecent, score, hits: s.hits });
  }

  // Strict filter first: require eligibility
  let ranked = entries
    .filter(e => e.veryRecent || e.recentCount >= 2)
    .sort((a, b) => (b.score - a.score) || (a.n - b.n))
    .slice(0, count);

  // If we’re still short, allow 1-hit numbers but only if that 1 hit was ≤R and not clearly decelerating
  if (ranked.length < count) {
    const picked = new Set(ranked.map(e => e.n));
    const fillers = entries
      .filter(e => !picked.has(e.n) && e.recentCount >= 1 && e.veryRecent)
      .sort((a, b) => (b.score - a.score) || (a.n - b.n))
      .slice(0, count - ranked.length);
    ranked = ranked.concat(fillers);
  }

  return ranked.map(e => e.n).sort((a, b) => a - b);
}

function getTopNumbersByFrequency(weeks, count){
  const w = Math.min(weeks, fullData.length);
  const recentDraws = fullData.slice(0, w)
    .map(row => row.slice(1).map(Number).filter(n => !isNaN(n)));

  const freq = {};
  recentDraws.forEach(draw => draw.forEach(n => { freq[n] = (freq[n] || 0) + 1; }));

  return Object.entries(freq)
    .sort((a,b) => (b[1]-a[1]) || (parseInt(a[0]) - parseInt(b[0])))
    .slice(0, count)
    .map(([n]) => parseInt(n, 10))
    .sort((a,b) => a - b);
}

// 👉 Put this once (helper to sync inputs to a list)
function setInputsFromList(list, limit = 12) {
  const box = document.getElementById('top18Inputs');
  if (!box) return;
  const inputs = box.querySelectorAll('input');
  for (let i = 0; i < limit; i++) {
    if (i < inputs.length) inputs[i].value = list[i] ?? '';
  }
  // clear any extra inputs (shouldn’t have more than 12 though)
  for (let i = limit; i < inputs.length; i++) inputs[i].value = '';
}

// Toast helper
function showToast(msg, ms=1600){
  let el = document.getElementById('tweToast');
  if(!el){
    el = document.createElement('div');
    el.id = 'tweToast';
    document.body.appendChild(el);
  }
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(showToast.__t);
  showToast.__t = setTimeout(()=> el.classList.remove('show'), ms);
}

// Set compare
function setsEqual(a, b){
  if(a.size !== b.size) return false;
  for (const v of a) if (!b.has(v)) return false;
  return true;
}

function readTopSkips12(){
  const inputs = Array.from(document.querySelectorAll('#top18Inputs input'));
  const first12 = inputs.slice(0, 12)
    .map(inp => parseInt(inp.value.trim(), 10))
    .filter(n => !isNaN(n));
  return Array.from(new Set(first12)).sort((a,b) => a - b);
}

// 🔁 Replace your existing computeSystemPicks with this:
// 👉 Drop-in replacement: blends Hot ∩ Top first, then Top, then Hot,
// while minimizing average points of sampled 5-number sets from the pool.
function computeSystemPicks(count, weeks, hotList = [], topList = [], sinceMapObj = {}, rng = rand) {  const uniq = arr => Array.from(new Set(arr)).filter(Number.isInteger);
  const H = uniq(hotList);
  const T = uniq(topList);

  const chosen = new Set();
  const push = n => { if (!chosen.has(n)) chosen.add(n); };

  function clumpPenalty(n) {
    let p = 0;
    chosen.forEach(c => {
      const d = Math.abs(c - n);
      if (d === 1) p += 2;
      else if (d === 2) p += 1;
    });
    return p;
  }
  function preScore(n) {
    const due = (sinceMapObj[n] || 0);  // bigger = longer since hit
    const inTop = T.includes(n) ? 1 : 0;
    const inHot = H.includes(n) ? 1 : 0;
    return (due * 1.0) + (inTop * 0.6) + (inHot * 0.4) - clumpPenalty(n) * 0.5;
  }

  // 1) consensus first
  H.filter(n => T.includes(n)).sort((a,b)=>preScore(b)-preScore(a)).forEach(n => { if (chosen.size < count) push(n); });

  // 2) ensure at least half from Top
  const wantTopMin = Math.max(Math.floor(count/2), 4);
  T.filter(n => !chosen.has(n)).sort((a,b)=>preScore(b)-preScore(a)).forEach(n => { if (chosen.size < wantTopMin) push(n); });

  // 3) fill from Hot
  H.filter(n => !chosen.has(n)).sort((a,b)=>preScore(b)-preScore(a)).forEach(n => { if (chosen.size < count) push(n); });

  // 4) backfill by raw frequency if still short
  if (chosen.size < count) {
    getTopNumbersByFrequency(weeks, totalNumbersGlobal)
      .filter(n => !chosen.has(n))
      .sort((a,b)=>(sinceMapObj[b]||0)-(sinceMapObj[a]||0))
      .forEach(n => { if (chosen.size < count) push(n); });
  }
  for (let n=1; chosen.size < count && n<=totalNumbersGlobal; n++) push(n);

  // 5) points-aware refinement (deterministic with rng)
  let pool = Array.from(chosen).sort((a,b)=>a-b);
  const candidateUniverse = uniq([...T, ...H, ...getTopNumbersByFrequency(weeks, Math.min(totalNumbersGlobal, 40))]);

  let currentScore = evaluatePoolPoints(pool, rng);
  let improved = true;
  let tries = 0;
  while (improved && tries < 40) {
    improved = false; tries++;
    for (let i = 0; i < pool.length; i++) {
      const base = pool.filter((_, idx) => idx !== i);

      const candidates = candidateUniverse
        .filter(n => !base.includes(n))
        .sort((a,b)=>preScore(b)-preScore(a))
        .slice(0, 20);

      let bestLocal = currentScore;
      let bestChoice = null;
      for (const cand of candidates) {
        const adjBad = base.some(x => Math.abs(x - cand) <= 1);
        if (adjBad && rng() < 0.4) continue;

        const trial = [...base, cand].sort((a,b)=>a-b);
        const trialScore = evaluatePoolPoints(trial, rng);
        if (trialScore < bestLocal) {
          bestLocal = trialScore;
          bestChoice = cand;
        }
      }
      if (bestChoice !== null) {
        pool = [...base, bestChoice].sort((a,b)=>a-b);
        currentScore = bestLocal;
        improved = true;
      }
    }
  }
  return pool.slice(0, count).sort((a,b)=>a-b);
}

// 🔁 REPLACE/ADD this function
function populateAllThreeOnLoad() {
  // 1) Top (orange): from current-since skip profile
  if (typeof recomputeTopFromSkips === 'function') {
    recomputeTopFromSkips(12);
  }

  // 2) Hot (blue): trending last 25
  const weeks = Math.min(25, fullData.length);
  const hot12 = computeTrendingHotNumbers(weeks, 12);
  hotSet = new Set(hot12);

  // 3) Picks (green): deterministic blend of Top+Hot+Due + points
  setDeterministicSeed('systemPicks');                 // ← important: same seed as button
  const picks12 = computeSystemPicks(12, weeks, hot12, top18, sinceMap);
  systemPicksSet = new Set(picks12);

  // Draw Hits table now that Top/Hot/Picks are ready
  renderReverseHitsTable();
  reapplySkipTableHighlights();

  // 👉 Mirror Picks into the 12 manual input boxes on load
  ensureTwelveInputs();
  setInputsFromList(picks12, 12);
}



// ✅ Keep your existing runSystemPicks, but add the marked lines:
function runSystemPicks(){
  if (totalNumbersGlobal === 26){
    alert('System Picks are not available in Powerball-only mode.');
    return;
  }

  const weeks = Math.min(25, fullData.length);
  const count = 12;

  // Ensure Hot exists
  if (!hotSet || hotSet.size === 0){
    const hotNums = computeTrendingHotNumbers(weeks, count);
    hotSet = new Set(hotNums);
  }
  // Ensure Top exists
  if (!top18 || top18.length === 0) {
    if (typeof recomputeTopFromSkips === 'function') recomputeTopFromSkips(12);
  }

  // Keep a copy for change detection
  const before = new Set(systemPicksSet);

  // Deterministic seed so button matches page-load result
  setDeterministicSeed('systemPicks');

  // Compute Picks
  const picks = computeSystemPicks(count, weeks, Array.from(hotSet), top18, sinceMap);

  // Save to Picks column
  systemPicksSet = new Set(picks);

  // Mirror Picks into the 12 inputs (sorted)
  ensureTwelveInputs();
  setInputsFromList(picks.slice().sort((a,b)=>a-b), 12);

  // Redraw
  renderReverseHitsTable();
  reapplySkipTableHighlights();

  // ✅ Feedback toast
  const changed = !setsEqual(before, systemPicksSet);
  showToast(changed ? 'System Picks updated.' : 'System Picks recalculated (no change).');
}

function ensureTwelveInputs() {
  const div = document.getElementById('top18Inputs');
  if (!div) return;
  div.innerHTML = '';
  for (let i = 0; i < 12; i++) {
    const inp = document.createElement('input');
    inp.type = 'text';
    inp.placeholder = String(i + 1);
    div.appendChild(inp);
  }
}

function randomSampleCombos(pool, k, samples, rng = rand) {
  const out = [];
  const n = pool.length;
  if (n < k) return out;

  for (let s = 0; s < samples; s++) {
    const idxs = new Set();
    while (idxs.size < k) idxs.add(Math.floor(rng() * n));
    const combo = Array.from(idxs).map(i => pool[i]).sort((a,b)=>a-b);

    const adj = combo.filter((x,i)=> i>0 && combo[i]-combo[i-1]===1).length;
    if (adj > 2 && rng() < 0.6) { s--; continue; } // same logic, seeded

    out.push(combo);
  }
  return out;
}

function evaluatePoolPoints(pool, rng = rand) {
  const combos = randomSampleCombos(pool, 5, 80, rng);
  if (combos.length === 0) return 1e9;
  let sum = 0;
  for (const c of combos) sum += calculateRawPointsForSet(c);
  return sum / combos.length;
}


function drawHistogram(points) {
  const maxToShow = 500;
  const recentPoints = points.slice(-maxToShow).reverse();
  const canvasWidth = 800;
  const barHeight = 18;
  const spacing = 4;
  const canvasHeight = (barHeight + spacing) * recentPoints.length;
  
  document.getElementById('histogramModal').style.display = 'block';

  const oldCanvas = document.getElementById('pointsCanvas');
  if (oldCanvas) oldCanvas.remove();

  const canvas = document.createElement('canvas');
  canvas.id = 'pointsCanvas';
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  canvas.style.display = 'block';
  canvas.style.margin = '20px auto';
  canvas.style.border = '2px solid gray';
  canvas.style.background = '#111';

  document.getElementById('histogramContent').appendChild(canvas);

  const ctx = canvas.getContext('2d');
  const sorted = [...recentPoints].sort((a, b) => a - b);
  const cutoffIndex = (totalNumbersGlobal === 39) ? (sorted.length - 1) : Math.floor(sorted.length * 0.95);
  const maxPoints = sorted[cutoffIndex];

  ctx.font = '14px Arial';
  ctx.textBaseline = 'middle';

  recentPoints.forEach((pts, i) => {
    const y = i * (barHeight + spacing);
    const logPts = Math.log10(pts + 1);
    const logMax = Math.log10(maxPoints + 1);
    const barWidth = (logPts / logMax) * (canvasWidth - 150);

    ctx.fillStyle = pts > 1200 ? 'red' : pts > 800 ? 'orange' : pts > 400 ? 'yellow' : 'lightgreen';
    ctx.fillRect(140, y, barWidth, barHeight);
    const offset = (totalNumbersGlobal === 39) ? 70 : (totalNumbersGlobal === 69) ? 260 : 0;
    ctx.fillStyle = 'white';
    ctx.fillText(`Draw ${points.length - i + offset}:`, 10, y + barHeight / 2);
    ctx.fillText(`${pts.toFixed(1)} pts`, 150 + barWidth, y + barHeight / 2);
  });
}

function setupHistogramListener() {
  const histoBtn = document.getElementById('showHistogramBtn');
  if (!histoBtn) return;

  histoBtn.onclick = () => {
    if (!fullData || !fullData.length) { alert("Load drawing data first."); return; }

    const drawingSets = fullData.map(row =>
      row.slice(1).map(n => parseInt(n)).filter(n => !isNaN(n))
    );
    const points = drawingSets.map(set => calculateRawPointsForSet(set));
    drawHistogram(points);
  };
}

function saveTop18Numbers() {
  const numbers = [];
  const rows = document.querySelectorAll('#reverseHitsContainer table tr');
  rows.forEach((row, idx) => {
    if (idx === 0) return;
    const topCell = row.querySelector('td:nth-last-child(3)'); // 'Top' is 3rd from end
    if (!topCell) return;
    if (topCell.querySelector('.orange-dot, .blue-dot')) {
      const th = row.querySelector('th');
      const num = th ? parseInt(th.textContent, 10) : NaN;
      if (!isNaN(num)) numbers.push(num);
    }
  });

  const count   = numbers.length;
  const allowed = [5, 12, 18];
  if (!allowed.includes(count)) {
    alert(`The Hits table currently shows ${count || 'no'} numbers in the ‘Picks’ column.\nPlease make sure it’s exactly 5, 12, or 18 before saving.`);
    return;
  }

  const nextDraw = (typeof latestDrawingNumber === 'number' && !isNaN(latestDrawingNumber)) ? latestDrawingNumber + 1 : '00000';
  const weeksField = document.getElementById('weeksInput');
  const weeksVal = weeksField ? (String(weeksField.value || '').padStart(2,'0') || '00') : '00';

  let filename;
  if (totalNumbersGlobal === 69) filename = `topPB_${count}_${weeksVal}_${nextDraw}.txt`;
  else if (totalNumbersGlobal === 39) filename = `topF5_${count}_${weeksVal}_${nextDraw}.txt`;
  else filename = `top_${count}_${weeksVal}_${nextDraw}.txt`;

  const blob = new Blob([numbers.join(',')], { type: 'text/plain' });
  const link = Object.assign(document.createElement('a'), { href: URL.createObjectURL(blob), download: filename });
  link.click();
}

function handleTop18FileSelect(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    // accept either comma or space-separated lists
    const contents = e.target.result.trim();
    const numbers = contents.split(/[^0-9]+/)
      .map(s => parseInt(s, 10))
      .filter(n => Number.isInteger(n));

    if (numbers.length === 0) {
      alert('No valid numbers found in the file.');
      return;
    }

    // Only take up to the first 12 numbers
    const picks12 = Array.from(new Set(numbers)).slice(0, 12).sort((a,b)=>a-b);
    loadPicksIntoColumnAndInputs(picks12);
    loadTop18Modal.style.display = 'none';
    loadTop18FileInput.value = '';
  };
  reader.readAsText(file);
}

function loadPicksIntoColumnAndInputs(numbers) {
  // Mirror into the 12 inputs
  ensureTwelveInputs();
  setInputsFromList(numbers, 12);

  // Update the green Picks column
  systemPicksSet = new Set(numbers);

  // Re-draw tables/highlights
  renderReverseHitsTable();
  reapplySkipTableHighlights();
}


function loadTop18NumbersIntoTable(numbers) {
  const container = document.getElementById('reverseHitsContainer');
  if (!container) return;
  const table = container.querySelector('table'); if (!table) return;

  const rows = table.querySelectorAll('tr');
  rows.forEach(row => {
    const topCell = row.querySelector('td:nth-last-child(3)');
    if (topCell) topCell.innerHTML = '';
  });

  top18 = numbers;
  const top18Inputs = Array.from(document.querySelectorAll('#top18Inputs input'));
  top18Inputs.forEach((input, index) => { input.value = numbers[index] ?? ''; });

  rows.forEach(row => {
    const num = parseInt(row.querySelector('th')?.textContent, 10);
    if (numbers.includes(num)) {
      const topCell = row.querySelector('td:nth-last-child(3)');
      if (topCell) {
        const blueDot = document.createElement('div');
        blueDot.className = 'blue-dot';
        topCell.appendChild(blueDot);
      }
    }
  });

  reapplySkipTableHighlights();
  loadTop18FileInput.value = '';
}

window.addEventListener('click', (event) => { if (event.target === loadTop18Modal) loadTop18Modal.style.display = 'none'; });

// Add CSS for the blue dot
const style = document.createElement('style');
style.textContent = `.blue-dot { width: 14px; height: 14px; border-radius: 50%; margin: auto; background: lightgreen; }`;
document.head.appendChild(style);

function highlight(btn){ [btn39, btn69, btn1].forEach(b => b.classList.toggle('active', b === btn)); }
function hidePBblock(){ pbBlk.style.display = 'none'; qsa('#pbBlock input').forEach(inp => inp.value = ''); }

function closeCheckModal() { const modal = document.getElementById("checkNumbersModal"); if (modal) modal.style.display = "none"; }
window.addEventListener("click", function(event) { const modal = document.getElementById("checkNumbersModal"); if (event.target === modal) modal.style.display = "none"; });

function showPBblock(){
  pbBlk.style.display='flex';
  const pool  = Array.from({length:26}, (_,i) => i+1);
  const picks = [];
  while (picks.length < 5) {
    const idx = Math.floor(Math.random() * pool.length);
    picks.push( pool.splice(idx,1)[0] );
  }
  qsa('#pbBlock input').forEach((inp,i) => inp.value = picks[i] ?? '');
}

qs('#generateWheelButton').onclick= ()=> qs('#wheelModal').style.display='block';

document.getElementById('generateSetsModalButton').onclick = generateWheelSets;
document.getElementById('pickBestSetsModal').onclick = ()=> pickBestSets(true);
document.getElementById('exportAllBtn').onclick = ()=> doExport('all');
document.getElementById('exportBestBtn').onclick = ()=> doExport('best');

function doExport(mode){
  if(!generatedSets.length){ alert('Generate sets first!'); return; }

  const allCount  = +qs('#modalSetCountChoice').value||1;
  const bestCount = +qs('#modalBestSetCount').value||1;
  let list = [...generatedSets];

  if(mode==='best'){
      list.sort((a,b)=>a.points-b.points);
      list = list.slice(0,bestCount);
  }else{
      list = list.slice(0,allCount);
  }

  const pbInputs = qsa('#pbBlock input').map(inp => parseInt(inp.value, 10)).filter(n => n >= 1 && n <= 26);
  const needPB = (totalNumbersGlobal === 69 || totalNumbersGlobal === 26);

  const lines = list.map(({combo},idx)=>{
let out = `${idx+1}.  ${asSorted(combo).join(', ')}`;
      if(needPB){
          const pb = pbInputs.length
                      ? pbInputs[Math.floor(Math.random()*pbInputs.length)]
                      : Math.floor(Math.random()*26)+1;
          out += '  '+pb;
      }
      return out;
  }).join('\n');

  const blob=new Blob([lines],{type:'text/plain'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  const prefix = (totalNumbersGlobal === 39) ? 'f5' : ((totalNumbersGlobal === 26 || totalNumbersGlobal === 69) ? 'pwb' : 'x'); // FIX
  const draw = (typeof latestDrawingNumber === 'number' ? latestDrawingNumber + 1 : '00000');
  a.download = `${mode}_sets_${prefix}_${draw}.txt`;
  a.click();
}

/* Check Numbers (file flow) */
document.getElementById("checkNumbersButton").onclick = function () {
  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.accept = ".txt";

  fileInput.onchange = function (evt) {
    const file = evt.target.files[0];
    if (!file) return;

    const filename = file.name;
    const match = filename.match(/(all|best)_sets_(f5|pwb).*?_(\d+)\.txt$/i);
    if (!match) { alert("Filename does not match expected pattern."); return; }

    const [, , mode, drawNumber] = match;
    const reader = new FileReader();

    reader.onload = function (e) {
      const lines = e.target.result.trim().split("\n").filter(Boolean);
      if (!lines.length) { alert("File appears to be empty."); return; }

      const drawLabel = document.getElementById("drawNumberLabel");
      if (drawLabel) drawLabel.textContent = `Drawing #${drawNumber}`;

      const lottoFile = (mode === "pwb") ? "lotto_69.txt" : "lotto_39.txt";
      fetch(lottoFile + "?t=" + Date.now())
        .then(res => res.ok ? res.text() : Promise.reject("Failed to load lotto file"))
        .then(text => {
          const line = text.trim().split("\n").find(line => line.startsWith(drawNumber + ","));
          if (!line) throw new Error("Drawing number not found in lotto file");

          const parts = line.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
          const nums = parts.slice(1, 6);
          let pb = null;

          if (mode === "pwb") {
            fetch("lotto_1.txt?t=" + Date.now())
              .then(res => res.ok ? res.text() : Promise.reject("Failed to load Powerball file"))
              .then(pbText => {
                const pbLine = pbText.trim().split("\n").find(line => line.startsWith(drawNumber + ","));
                if (!pbLine) throw new Error("Matching Powerball not found for draw #" + drawNumber);
                const pbParts = pbLine.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
                pb = pbParts[1];
                checkAgainstSets(lines, nums, pb, mode, drawNumber);
              })
              .catch(err => { alert(err); console.error("⚠️ Powerball fetch error:", err); });
          } else {
            checkAgainstSets(lines, nums, null, mode, drawNumber);
          }
        })
        .catch(err => { alert(err); console.error("⚠️ Lotto file fetch error:", err); });
    };

    reader.readAsText(file);
  };

  fileInput.click();
};

function checkAgainstSets(lines, nums, pb, mode, drawNumber) {
  const winDisplay = document.getElementById("winningNumbersDisplay");
  if (winDisplay) winDisplay.textContent = nums.join(", ");

  const pbDisplay = document.getElementById("winningPBDisplay");
  if (pbDisplay) {
    if (mode === "pwb" && pb !== null) {
      pbDisplay.textContent = `+ PB: ${pb}`;
      pbDisplay.style.display = "inline";
    } else {
      pbDisplay.textContent = "";
      pbDisplay.style.display = "none";
    }
  }

  const matchDiv = document.getElementById("matchResults");
  matchDiv.innerHTML = "";
  let foundMatch = false;

  for (const line of lines) {
    const cleanLine = line.replace(/^\d+\.\s*/, '');
    const numbers = cleanLine.match(/\d+/g)?.map(Number).filter(n => !isNaN(n));
    if (!numbers || numbers.length < 5) continue;

    const picks = numbers.slice(0, 5);
    const bonus = (mode === "pwb" && numbers.length >= 6) ? numbers[5] : null;

    const matchCount = picks.filter(n => nums.includes(n)).length;
    const pbMatch = (mode === "pwb" && pb !== null && bonus === pb);

    let tier = "", color = "";
    if (matchCount === 5 && pbMatch)      { tier = "5 + PB";  color = "red"; }
    else if (matchCount === 5)            { tier = "5";       color = "red"; }
    else if (matchCount === 4 && pbMatch) { tier = "4 + PB";  color = "orange"; }
    else if (matchCount === 4)            { tier = "4";       color = "orange"; }
    else if (matchCount === 3 && pbMatch) { tier = "3 + PB";  color = "yellow"; }
    else if (matchCount === 3)            { tier = "3";       color = "yellow"; }
    else if (matchCount === 2 && pbMatch) { tier = "2 + PB";  color = "green"; }
    else if (matchCount === 1 && pbMatch) { tier = "1 + PB";  color = "green"; }
    else if (pbMatch)                     { tier = "PB Only"; color = "green"; }
    else if (mode === "f5" && matchCount === 2) { tier = "2"; color = "lightblue";}

    if (tier) {
      foundMatch = true;
      const div = document.createElement("div");
      div.textContent = `${picks.join(', ')} ➔ Matched ${tier}`;
      div.style.color = color;
      matchDiv.appendChild(div);
    }
  }

  if (!foundMatch) {
    const div = document.createElement("div");
    div.textContent = "No matches were found.";
    div.style.color = "yellow";
    matchDiv.appendChild(div);
  }

  const prizeFile = `${mode}_${drawNumber}.txt`;
  fetch(prizeFile + "?t=" + Date.now())
    .then(r => r.ok ? r.text() : Promise.reject("Could not load prize file."))
    .then(text => renderPrizeTable(text))
    .catch(err => {
      console.warn("⚠️ Prize file error:", err);
      const table = document.getElementById("prizeTable");
      const tbody = table.querySelector("tbody");
      tbody.innerHTML = "";
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 3;
      td.style.color = "orange";
      td.textContent = String(err);
      tr.appendChild(td);
      tbody.appendChild(tr);
    });

  const modal = document.getElementById("checkNumbersModal");
  if (modal) modal.style.display = "block";
}

/* FIXED: render prize table into the existing table structure */
function renderPrizeTable(tsvText) {
  const lines = tsvText.trim().split("\n");
  const table = document.getElementById("prizeTable");
  const thead = table.querySelector("thead");
  const tbody = table.querySelector("tbody");
  // reset thead/tbody
  thead.innerHTML = "";
  tbody.innerHTML = "";

  lines.forEach((line, idx) => {
    const tr = document.createElement("tr");
    const cells = line.split("\t");

    let rowColor = "lightgreen";
    if (idx !== 0) {
      const tier = cells[0].toLowerCase();
      if (tier.includes("5 of 5") || tier.includes("5 + powerball")) rowColor = "red";
      else if (tier.includes("4 of 5") || tier.startsWith("4 +")) rowColor = "orange";
      else if (tier.includes("3 of 5") || tier.startsWith("3 +")) rowColor = "yellow";
      else if (tier.includes("2 of 5") || tier.includes("powerball")) rowColor = "lightblue";
      else if (tier.includes("total winning")) rowColor = "gold";
    }

    cells.forEach((cellText) => {
      const cell = document.createElement(idx === 0 ? "th" : "td");
      cell.textContent = cellText;
      cell.style.border = "1px solid gray";
      cell.style.padding = "6px";
      cell.style.textAlign = "left";
      cell.style.color = rowColor;
      tr.appendChild(cell);
    });

    if (idx === 0) {
      thead.appendChild(tr);
    } else {
      tbody.appendChild(tr);
    }
  });
}

document.getElementById('updateHitsBtn').addEventListener('click', updateReverseHitsTop18);

/* Generate Wheel modal open */
const showModalButton = document.getElementById('generateWheelButton');
if (showModalButton) showModalButton.addEventListener('click', function() { document.getElementById('wheelModal').style.display = "block"; });

const generateSetsButtonModal = document.getElementById('generateSetsModalButton');
if (generateSetsButtonModal) generateSetsButtonModal.addEventListener('click', generateWheelSets);

/* Unified close handlers for all .close-button */
document.querySelectorAll('.close-button').forEach(btn => {
  btn.addEventListener('click', function () {
    const modal = this.closest('.modal');
    if (modal) {
      modal.style.display = 'none';
      if (modal.id === 'wheelModal') resetModalControls();
      if (modal.id === 'checkNumbersModal') reapplySkipTableHighlights();
    }
  });
});

/* Click outside modals */
window.addEventListener('click', function(event) {
  if (event.target == wheelModal) {
    resetModalControls();
    wheelModal.style.display = "none";
    if (totalNumbersGlobal === 26) reapply69State();
  }
});

/* Reference data */
function loadReferenceData() {
  const refFile = (totalNumbersGlobal === 39) ? 'f5_refSet.csv' : (totalNumbersGlobal === 69) ? 'pwb_refSet.csv' : null;
  if (!refFile) { console.warn('⚠️ Unsupported totalNumbersGlobal:', totalNumbersGlobal); return; }

  fetch(refFile + '?t=' + Date.now())
    .then(response => response.text())
    .then(csv => {
      const lines = csv.trim().split('\n');
      referenceData = {};
      for (let i = 1; i < lines.length; i++) {
        const row = lines[i].split(',');
        const category = row[0].trim();
        const diff = parseInt(row[1]);
        const cumP = parseFloat(row[3]);
        if (!referenceData[category]) referenceData[category] = {};
        referenceData[category][diff] = cumP;
      }
    })
    .catch(error => { console.error(`❌ Failed to load ${refFile}:`, error); });
}
window.addEventListener('DOMContentLoaded', function() { loadReferenceData(); resetModalControls(); });

document.getElementById('quick12Button').addEventListener('click', function () {
  top18From69 = Array.from(document.querySelectorAll('#top18Inputs input'))
      .map(inp => parseInt(inp.value.trim(), 10))
      .filter(n => !isNaN(n) && n >= 1)
      .sort((a, b) => a - b);
  const allInputs = Array.from(document.querySelectorAll('#top18Inputs input'));
  const topInputs = allInputs.map(inp => parseInt(inp.value.trim(), 10)).filter(n => !isNaN(n));
  if (topInputs.length < 12) { alert('Need at least 12 valid numbers in the Your Picks inputs.'); return; }

  const fixedPattern = [
      [0, 1, 2, 3, 4], [0, 1, 5, 6, 7], [0, 2, 5, 8, 9],
      [0, 3, 6, 8, 10], [1, 2, 6, 9, 10], [1, 3, 5, 9, 11]
  ];

  let bestOrder = null;
  let bestScore = Infinity;

  const tryCount = 10000;
  for (let i = 0; i < tryCount; i++) {
    const shuffled = topInputs.slice(0, 12).sort(() => 0.5 - Math.random());
    let totalScore = 0;
    for (const indexes of fixedPattern) {
      const combo = indexes.map(i => shuffled[i]);
      totalScore += calculateRawPointsForSet(combo);
    }
    if (totalScore < bestScore) { bestScore = totalScore; bestOrder = shuffled.slice(0, 12); }
  }

// NEW: write inputs low→high for easy ticket entry
const sortedForInputs = asSorted(bestOrder);
allInputs.forEach((inp, idx) => {
  if (idx < 12) { inp.value = sortedForInputs[idx]; inp.classList.remove('dimmed'); }
  else { inp.classList.add('dimmed'); }
});


  document.getElementById('generateSetsModalButton').style.display = 'none';
  document.getElementById('pickBestSetsModal').style.display = 'none';
  document.getElementById('modalSetCountChoice').style.display = 'none';
  document.getElementById('modalBestSetCount').style.display = 'none';
  document.getElementById('exportBestBtn').style.display = 'none';
  document.querySelectorAll('#wheelModal label').forEach(label => label.style.display = 'none');

const fixedSets = fixedPattern.map(indexes =>
  asSorted(indexes.map(i => bestOrder[i]))
);  
generatedSets = fixedSets.map(combo => ({ combo, points: calculateRawPointsForSet(combo) }));

  const modal = document.getElementById('wheelModal');
  const output = document.getElementById('modalWheelOutput');

  let html = '<ol>';
  generatedSets.forEach(({ combo, points }) => {
    html += `<li style="color:${getColorForPoints(points)}">${combo.join(', ')} ➔ <b>${points.toFixed(1)} pts</b></li>`;
  });
  html += `</ol><p style="color:orange; font-weight:bold;">  Total Score: ${bestScore.toFixed(1)} pts</p>`;

  output.innerHTML = html;
  modal.style.display = 'block';
});

function renderFixedSetsToModal() {
  const modal = document.getElementById('wheelModal');
  const output = document.getElementById('modalWheelOutput');
  const progress = document.getElementById('progressInfo');

  document.getElementById('generateSetsModalButton').style.display = 'none';
  document.getElementById('pickBestSetsModal').style.display = 'none';
  document.getElementById('modalSetCountChoice').style.display = 'none';
  document.getElementById('modalBestSetCount').style.display = 'none';

  let html = '<ol>';
  generatedSets.forEach(({ combo, points }) => {
html += `<li style="color:${getColorForPoints(points)}">${asSorted(combo).join(', ')} ➔ <b>${points.toFixed(1)} pts</b></li>`;
  });
  html += '</ol>';
  output.innerHTML = html;

  if (progress) progress.innerHTML = '';
  modal.style.display = 'block';
}

function resetModalControls() {
  document.getElementById('generateSetsModalButton').style.display = 'inline-block';
  document.getElementById('pickBestSetsModal').style.display = 'inline-block';
  document.getElementById('modalSetCountChoice').style.display = 'inline-block';
  document.getElementById('modalBestSetCount').style.display = 'inline-block';
  document.getElementById('exportBestBtn').style.display = 'inline-block';

  const labels = document.querySelectorAll('#wheelModal label');
  labels.forEach(label => label.style.display = 'inline-block');

  document.querySelectorAll('#top18Inputs input.dimmed').forEach(inp => inp.classList.remove('dimmed'));

  const output = document.getElementById('modalWheelOutput');
  const progress = document.getElementById('progressInfo');
  if (output) output.innerHTML = '';
  if (progress) progress.innerHTML = '';
}

function reapplySkipTableHighlights() {
  const table = document.querySelector('#skipFrequencyContainer table');
  if (!table) return;

  const rows = table.querySelectorAll('tr');
  rows.forEach(row => {
    const num = parseInt(row.querySelector('th')?.textContent, 10);
    row.querySelectorAll('td').forEach((cell, i) => {
      const val = parseInt(cell.textContent.trim());
      cell.classList.remove('selected-top-skip', 'top18-selected', 'hit');
      if (val > 0) cell.classList.add('hit');
      if (sinceMap[num] === i + 1) cell.classList.add('selected-top-skip');
    });

    if (top18.includes(num)) {
      row.querySelectorAll('td').forEach(cell => {
        if (cell.classList.contains('selected-top-skip')) {
          cell.classList.remove('selected-top-skip');
          cell.classList.add('top18-selected');
        }
      });
    }
  });

}

function reapply69State() {
  highlight(btn69);
  totalNumbersGlobal = 69;
  hidePBblock();

  fullData = [...fullDataFrom69];
  skipDataGlobal = JSON.parse(JSON.stringify(skipDataGlobalFrom69));
  sinceMap = { ...sinceMapFrom69 };
  pastDrawings = [...pastDrawingsFrom69];
  top18 = [...top18From69];

  const top18InputsDiv = document.getElementById('top18Inputs');
  top18InputsDiv.innerHTML = '';
  for (let i = 0; i < top18.length; i++) {
    if (i === 12) {
      const divider = document.createElement('div');
      divider.style.borderLeft = '3px solid red';
      divider.style.margin = '0 6px';
      divider.style.height = '34px';
      divider.style.alignSelf = 'center';
      top18InputsDiv.appendChild(divider);
    }
    const inp = document.createElement('input');
    inp.type = 'text';
    inp.value = top18[i];
    top18InputsDiv.appendChild(inp);
  }

  updateReverseHitsTop18();
  renderSkipFrequency();
}

function generateWheelSets() {
const top18Inputs = Array.from(document.querySelectorAll('#top18Inputs input'));
const numbersToUse = top18Inputs
  .map(input => parseInt(input.value.trim(), 10))
  .filter(x => Number.isInteger(x) && x >= 1);

if (numbersToUse.length < 12) {
  alert('Please enter 12 valid numbers in the input boxes.');
  return;
}

// ✅ Use a local source for wheel generation; do NOT change Top
const wheelSource = numbersToUse.sort((a, b) => a - b);


  const progressDiv = document.getElementById('progressInfo') || createProgressInfoDiv();
  progressDiv.innerHTML = '';

  const setsToGenerateInput = document.getElementById('modalSetCountChoice');
  const setsToGenerate = parseInt(setsToGenerateInput.value, 10) || 6;

  const wheelSets = generateWheel(wheelSource, pastDrawings, 5, setsToGenerate);
  generatedSets = wheelSets.map(({ combo }) => ({ combo, points: calculateRawPointsForSet(combo) }));

  const modalWheelOutput = document.getElementById('modalWheelOutput');
  const wheelModal = document.getElementById('wheelModal');

  if (generatedSets.length === 0) {
      modalWheelOutput.innerHTML = '<p>No valid sets generated. Try different numbers or sets.</p>';
      wheelModal.style.display = "block";
      return;
  }

  let outputHtml = '<ol>';
  generatedSets.forEach(({ combo, points }) => {
      const color = getColorForPoints(points);
      outputHtml += `<li style="color:${color};">${combo.join(', ')} ➔ <b>${points.toFixed(1)} pts</b></li>`;
  });
  outputHtml += '</ol>';
  modalWheelOutput.innerHTML = outputHtml;
  wheelModal.style.display = "block";
}

function createProgressInfoDiv() {
  const div = document.createElement('div');
  div.id = 'progressInfo';
  div.style.marginTop = '15px';
  div.style.fontSize = '16px';
  const modalContent = document.querySelector('#wheelModal .modal-content');
  if (modalContent) modalContent.insertBefore(div, document.getElementById('modalWheelOutput'));
  return div;
}

function getColorForPoints(points) {
  if (points < 400) return 'lightgreen';
  if (points < 800) return 'yellow';
  if (points < 1200) return 'orange';
  return 'red';
}

function calculateRawPointsForSet(numbers) {
  let totalPoints = 0;
  const sorted = [...numbers].sort((a, b) => a - b);

  const sum = sorted.reduce((a, b) => a + b, 0);
  const spread = sorted[4] - sorted[0];
  const lowHigh = sorted[0] - sorted[4];
  const consecutivePairs = sorted.filter((n, i) => i < 4 && sorted[i + 1] - n === 1).length;
  const oddEven = sorted.filter(n => n % 2 === 1).length - sorted.filter(n => n % 2 === 0).length;
  const midpoint = totalNumbersGlobal / 2;
  const lowHighBalance = sorted.filter(n => n <= midpoint).length - sorted.filter(n => n > midpoint).length;

  const positionDiffs = {
      "1 - 2": sorted[0] - sorted[1],
      "2 - 3": sorted[1] - sorted[2],
      "3 - 4": sorted[2] - sorted[3],
      "4 - 5": sorted[3] - sorted[4]
  };

  const lookup = [
      { category: "Sum", value: sum },
      { category: "Spread", value: spread },
      { category: "Low - High", value: lowHigh },
      { category: "Odd - Even", value: oddEven },
      { category: "LowHigh Balance", value: lowHighBalance },
      { category: "Consecutive Pairs", value: consecutivePairs },
      { category: "1 - 2", value: positionDiffs["1 - 2"] },
      { category: "2 - 3", value: positionDiffs["2 - 3"] },
      { category: "3 - 4", value: positionDiffs["3 - 4"] },
      { category: "4 - 5", value: positionDiffs["4 - 5"] },
      { category: "Min", value: sorted[0] },
      { category: "Max", value: sorted[4] },
      { category: "Center (3rd)", value: sorted[2] }
  ];

  lookup.forEach(({ category, value }) => {
      const p = referenceData[category]?.[value];
      if (p && p > 0) totalPoints += 1 / Math.max(p, 1e-4);
  });

  return totalPoints;
}

function processLoadedData() {
  const drawingNumbers = fullData.map(row => parseInt(row[0]));
  const data = fullData.map(row => row.slice(1).map(Number)).filter(row => row.every(n => !isNaN(n)));

  skipDataGlobal = buildSkipTable(data, totalNumbersGlobal, drawingNumbers);

  pastDrawings = fullData.filter(row => row.length >= 6)
                         .map(row => row.slice(1, 6).sort((a, b) => a - b).join(','));

  renderRecentDraws(data, totalNumbersGlobal, drawingNumbers[0]);
  renderSkipFrequency();
}

/* Skip table builders/renders */
function buildSkipTable(data, totalNumbers, drawingNumbers) {
  const skipTable = Array.from({ length: totalNumbers + 1 }, () => Array(26).fill(0));
  const lastSeen = Array(totalNumbers + 1).fill(null);

  for (let drawIndex = 0; drawIndex < data.length; drawIndex++) {
      const currentDraw = new Set(data[drawIndex]);
      for (let num = 1; num <= totalNumbers; num++) {
          if (currentDraw.has(num)) {
              if (lastSeen[num] !== null) {
                  const skip = drawIndex - lastSeen[num] - 1;
                  if (skip >= 1 && skip <= 25) skipTable[num][skip]++;
              }
              lastSeen[num] = drawIndex;
          }
      }
  }
  return { skipTable };
}

function renderRecentDraws(data, totalNumbers, latestDrawingNumber) {
  const container = document.getElementById('recentDrawsContainer');
  const comment = document.getElementById('latestDrawingComment');
  comment.textContent = `The latest drawing on file is drawing # ${latestDrawingNumber}, shown in column 1.`;

  const draws = data.slice(0, 25);
  while (draws.length < 25) draws.push([]);

  sinceMap = {};
  const table = document.createElement('table');
  const headerRow = document.createElement('tr');
  headerRow.appendChild(document.createElement('th'));
  for (let i = 1; i <= 25; i++) {
      const th = document.createElement('th');
      th.textContent = i;
      headerRow.appendChild(th);
  }
  table.appendChild(headerRow);

  for (let number = 1; number <= totalNumbers; number++) {
      const row = document.createElement('tr');
      const th = document.createElement('th');
      th.textContent = number;
      row.appendChild(th);

      let found = false;
      for (let col = 0; col < 25; col++) {
          const cell = document.createElement('td');
          if (draws[col] && draws[col].includes(number)) {
              const dot = document.createElement('div');
              dot.className = 'red-dot';
              cell.appendChild(dot);
              if (!found) { sinceMap[number] = col + 1; found = true; }
          }
          row.appendChild(cell);
      }
      if (!found) { sinceMap[number] = draws.length + 1; }
      table.appendChild(row);
  }

  container.innerHTML = '';
  container.appendChild(table);
}

function renderSkipFrequency() {
  const container = document.getElementById('skipFrequencyContainer');
  container.innerHTML = '';

  const table = document.createElement('table');
  const headerRow = document.createElement('tr');
  headerRow.appendChild(document.createElement('th'));
  for (let i = 1; i <= 25; i++) {
    const th = document.createElement('th');
    th.textContent = i;
    headerRow.appendChild(th);
  }
  table.appendChild(headerRow);

  for (let number = 1; number <= totalNumbersGlobal; number++) {
    const row = document.createElement('tr');
    const th = document.createElement('th');
    th.textContent = number;
    row.appendChild(th);

    for (let i = 1; i <= 25; i++) {
      const cell = document.createElement('td');
      const val = skipDataGlobal.skipTable[number]?.[i] || 0;
      cell.textContent = val > 0 ? val : '';
      row.appendChild(cell);
    }
    table.appendChild(row);
  }
  container.appendChild(table);
}

/* Wheel generation / coverage */
function generateWheel(sourceNumbers, pastDrawings, setSize, numSets) {
  const wheel = [];
  const used = new Set();
  const seenCombos = new Set();
  let skippedDueToPastDrawings5 = 0;
  let skippedDueToBadSum = 0;
  let skippedDueToHighPoints = 0;
  let attempts = 0;

  const totalCombosNeeded = combination(sourceNumbers.length, 3);

  const minPossibleSum = sourceNumbers.slice(0, 5).reduce((a, b) => a + b, 0);
  const maxPossibleSum = sourceNumbers.slice(-5).reduce((a, b) => a + b, 0);
  const span = maxPossibleSum - minPossibleSum;
  const minSumAllowed = minPossibleSum + span * 0.15;
  const maxSumAllowed = minPossibleSum + span * 0.85;

  const maxPointsAllowed = 1200;

  const progressDiv = document.getElementById('progressInfo') || createProgressInfoDiv();
  progressDiv.innerHTML = '';

  while (wheel.length < numSets && attempts < 50000) {
    const combo = [...sourceNumbers].sort(() => 0.5 - Math.random()).slice(0, setSize).sort((a, b) => a - b);
    const comboKey = combo.join(',');

    if (used.has(comboKey)) { attempts++; continue; }

    const sum = combo.reduce((a, b) => a + b, 0);
    if (sum < minSumAllowed || sum > maxSumAllowed) { skippedDueToBadSum++; attempts++; continue; }

    let conflict = false;
    for (let i = 0; i < pastDrawings.length; i++) {
      const past = pastDrawings[i].split(',').map(Number);
      const overlap = combo.filter(n => past.includes(n));
      if (overlap.length === 5) { skippedDueToPastDrawings5++; conflict = true; break; }
    }
    if (conflict) { attempts++; continue; }

    const score = calculateRawPointsForSet(combo);
    if (score > maxPointsAllowed) { skippedDueToHighPoints++; attempts++; continue; }

    used.add(comboKey);
    const threeCombos = getAllCombinations(combo, 3);
    for (const c of threeCombos) seenCombos.add(c.join(','));

    wheel.push({ combo, points: score });

    progressDiv.innerHTML = `
      <div style="color: red;">🔥 Skipped ${skippedDueToPastDrawings5} sets (5/5 match)</div>
      <div style="color: orange;">🚫 Skipped ${skippedDueToBadSum} sets (bad sum)</div>
      <div style="color: violet;">⛔ Skipped ${skippedDueToHighPoints} sets (score > ${maxPointsAllowed})</div>
      <div style="color: lightgreen;">✅ 3-number combos covered: ${seenCombos.size} / ${totalCombosNeeded}</div>
    `;

    if (seenCombos.size >= totalCombosNeeded * 0.95) {
      const doneMessage = document.createElement('div');
      doneMessage.innerHTML = '🎯 95% of 3-combos covered!';
      doneMessage.style.color = 'lime';
      progressDiv.appendChild(doneMessage);
    }

    attempts++;
  }

  return wheel;
}

function estimateCoverage(numSets, totalNumbers) {
  const combosPerSet = combination(5, 3);
  const totalCombos = combination(totalNumbers, 3);
  const coverage = (numSets * combosPerSet) / totalCombos * 100;
  return coverage.toFixed(1);
}

function getAllCombinations(array, size) {
  const results = [];
  function helper(start, combo) {
    if (combo.length === size) { results.push(combo); return; }
    for (let i = start; i < array.length; i++) helper(i + 1, combo.concat(array[i]));
  }
  helper(0, []);
  return results;
}

function combination(n, k) {
  if (k > n) return 0;
  let result = 1;
  for (let i = 0; i < k; i++) result *= (n - i) / (i + 1);
  return Math.round(result);
}

function calculateCoveragePercent(numNumbers, setsGenerated) {
  const totalCombos = combination(numNumbers, 3);
  const combosCovered = setsGenerated * combination(5, 3);
  let percent = Math.min(100, (combosCovered / totalCombos) * 100);
  return percent.toFixed(1);
}

/* Reverse hits table (Skips / Hot / Picks) */
function renderReverseHitsTable() {
  const container = document.getElementById('reverseHitsContainer');
  container.innerHTML = '';

  const table = document.createElement('table');

  const headerRow = document.createElement('tr');
  headerRow.appendChild(document.createElement('th'));
  for (let i = 25; i >= 1; i--) {
    const th = document.createElement('th');
    th.textContent = i;
    headerRow.appendChild(th);
  }
headerRow.appendChild(document.createElement('th')).textContent = 'Skips';
headerRow.appendChild(document.createElement('th')).textContent = 'Hot';
headerRow.appendChild(document.createElement('th')).textContent = 'Picks';

  table.appendChild(headerRow);

  const draws = fullData.map(row => row.slice(1).map(n => parseInt(n, 10))).slice(0, 25);

  for (let number = 1; number <= totalNumbersGlobal; number++) {
    const row = document.createElement('tr');
    const th = document.createElement('th');
    th.textContent = number;
    row.appendChild(th);

    for (let i = 24; i >= 0; i--) {
      const cell = document.createElement('td');
      if (draws[i] && draws[i].includes(number)) {
        const dot = document.createElement('div');
        dot.className = 'red-dot';
        cell.appendChild(dot);
      }
      row.appendChild(cell);
    }

    const topCell = document.createElement('td');
    if (totalNumbersGlobal !== 26 && top18.includes(number)) {
      const dot = document.createElement('div'); dot.className = 'orange-dot'; topCell.appendChild(dot);
    }
    row.appendChild(topCell);

    const hotCell = document.createElement('td');
    if (hotSet && hotSet.has(number)) { const d = document.createElement('div'); d.className = 'hot-dot'; hotCell.appendChild(d); }
    row.appendChild(hotCell);

    const picksCell = document.createElement('td');
    if (systemPicksSet && systemPicksSet.has(number)) { const b = document.createElement('div'); b.className = 'green-dot'; picksCell.appendChild(b); }
    row.appendChild(picksCell);

    table.appendChild(row);
  }

  container.appendChild(table);
}

function updateReverseHitsTop18() {
  // Read exactly the 12 inputs you typed
  const picks = Array.from(document.querySelectorAll('#top18Inputs input'))
    .map(inp => parseInt(inp.value.trim(), 10))
    .filter(n => !isNaN(n))
    .slice(0, 12)
    .sort((a,b)=>a-b);

  // Update ONLY the green Picks column
  systemPicksSet = new Set(picks);

  // Do not touch Top or Hot
  renderReverseHitsTable();
  reapplySkipTableHighlights();
}


/* Exports */
function exportGeneratedSets() {
  if (generatedSets.length === 0) { alert("No generated sets!"); return; }
  const text = generatedSets.map(({ combo, points }) => `${combo.join(', ')} ➔ ${points.toFixed(1)} pts`).join('\n');
  const blob = new Blob([text], { type: 'text/plain' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'generated_sets_' + totalNumbersGlobal + '.txt';
  link.click();
}

function exportBestSets() {
  if (!generatedSets.length) { alert("No generated sets!"); return; }

  const bestCount = parseInt(document.getElementById('modalBestSetCount')?.value, 10) || 5; // FIX
  const sorted = [...generatedSets].sort((a,b) => a.points - b.points);
  const bestSets = sorted.slice(0, bestCount);

  if (bestSets.length === 0) { alert("No best sets available!"); return; }

  const text = bestSets.map(({ combo, points }) => `${combo.join(', ')} ➔ ${points.toFixed(1)} pts`).join('\n');
  const blob = new Blob([text], { type: 'text/plain' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  const prefix = (totalNumbersGlobal === 39) ? 'f5' : ((totalNumbersGlobal === 26 || totalNumbersGlobal === 69) ? 'pwb' : 'x'); // FIX
  const draw = latestDrawingNumber || '00000';
  link.download = `best_sets_${prefix}_${draw}.txt`;
  link.click();
}

/* Additional check flow (CSV-style) */
document.addEventListener("DOMContentLoaded", function() {
  const fileInput = document.getElementById("checkFileInput");
  if (!fileInput) return;
  fileInput.addEventListener("change", function(evt) {
    const file = evt.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
      const content = e.target.result;
      const lines = content.trim().split("\n");
      const nums = Array.from(document.querySelectorAll(".check-num")).map(n => parseInt(n.value)).filter(n => !isNaN(n));
      const pb = parseInt(document.getElementById("checkPB").value);
      const hasPB = !isNaN(pb) && totalNumbersGlobal === 69;
      const resultsDiv = document.getElementById("matchResults");
      resultsDiv.innerHTML = "";
      let matchFound = false;

      lines.forEach(line => {
        const match = line.trim().match(/^\d+\.\s*(.+?)\s{2,}(\d+)$/);
        if (!match) return;
        const numberPart = match[1].replace(/\s/g, '');
        const powerball = parseInt(match[2]);
        const picks = numberPart.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
        if (picks.length !== 5) return;

        const matchCount = picks.filter(n => nums.includes(n)).length;
        const pbMatch = hasPB && powerball === pb;

        let tier = "", color = "";
        if (matchCount === 5 && pbMatch)      { tier = "5 + PB";  color = "red";    }
        else if (matchCount === 5)            { tier = "5";       color = "red";    }
        else if (matchCount === 4 && pbMatch) { tier = "4 + PB";  color = "orange"; }
        else if (matchCount === 4)            { tier = "4";       color = "orange"; }
        else if (matchCount === 3 && pbMatch) { tier = "3 + PB";  color = "yellow"; }
        else if (matchCount === 3)            { tier = "3";       color = "yellow"; }
        else if (matchCount === 2 && pbMatch) { tier = "2 + PB";  color = "green";  }
        else if (matchCount === 1 && pbMatch) { tier = "1 + PB";  color = "green";  }
        else if (pbMatch)                     { tier = "PB Only"; color = "green";  }

        if (tier) {
          matchFound = true;
          const div = document.createElement("div");
          div.style.color = color;
          div.textContent = line.trim() + " ➔ " + tier;
          resultsDiv.appendChild(div);
        }
      });

      if (!matchFound) {
        const div = document.createElement("div");
        div.style.color = "yellow";
        div.textContent = "No matches found in any tier.";
        resultsDiv.appendChild(div);
      }
    };
    reader.readAsText(file);
  });
});

/* Histogram modal close */
document.addEventListener('DOMContentLoaded', () => {
  const closeBtn = document.getElementById('closeHistogramModal');
  if (closeBtn) closeBtn.addEventListener('click', () => { document.getElementById('histogramModal').style.display = 'none'; });
});
window.addEventListener('click', event => {
  if (event.target === document.getElementById('histogramModal')) document.getElementById('histogramModal').style.display = 'none';
});

/* On first load, we let the splash auto-click load 69 below */
window.addEventListener('load', function() {
  setTimeout(() => {
    const splash = document.getElementById('splashScreen');
    if (splash) {
      splash.style.opacity = 0;
      splash.style.transition = 'opacity 0.5s ease';
      setTimeout(() => splash.remove(), 500);
    }
    const btn69 = document.getElementById('powerball');
    if (btn69) btn69.click();
  }, 3800);
});
</script>
</body>
</html>
