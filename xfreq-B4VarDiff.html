
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Roulette P-Values</title>
  <style>
    .framed-buttons {
      border: 2px solid lightblue;
      padding: 15px;
      background-color: #f9f9f9;
      border-radius: 10px;
      display: inline-flex;
      flex-wrap: wrap;
      justify-content: space-around;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 5px;
      max-width: 500px;
      text-align: center;
      color: black;
    }
    .close-button {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 20px;
      background: none;
      border: none;
      cursor: pointer;
    }
    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      padding: 20px;
      box-sizing: border-box;
    }
    body {
      background-color: black;
      color: lightgreen;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      font-size: 16px;
    }
    .container h1 {
      margin: 0;
    }
    .button {
      font-size: 120%;
      padding: 6px 12px;
      margin: 5px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .button:hover {
      opacity: 0.8;
    }
    .button-single {
      background-color: salmon;
      color: black;
    }
    .button-purple {
      background-color: purple;
      color: white;
    }
    #viewDataButton {
      background-color: lightgray;
      color: black !important;
    }
    .header-container {
      text-align: center;
      margin: 20px 0;
    }
    .header-text {
      color: lightgreen;
      font-size: 48px;
    }
    .results-container {
      border: 2px solid white;
      padding: 20px;
      margin: 20px auto;
      width: 80%;
      max-width: 800px;
      background-color: #333;
      border-radius: 10px;
    }
    .results-container h3 {
      color: lightgreen;
      margin-bottom: 10px;
    }
    .results-container p {
      color: white;
      margin: 5px 0;
    }
    #explanation {
      border: 1px solid lightgreen;
      padding: 10px;
      margin-bottom: 20px;
      background-color: #222;
      border-radius: 5px;
      color: white;
    }
    #topContributors {
      color: white;
    }
    input[type="file"] {
      margin-bottom: 15px;
      color: black;
      background-color: lightgreen;
      padding: 5px;
      border: 1px solid white;
      border-radius: 5px;
    }
    input[type="file"]:hover {
      background-color: white;
      color: black;
      cursor: pointer;
    }
    .button-DarkKhaki {
      background-color: DarkKhaki;
      color: black !important;
    }
    .button-DarkSeaGreen {
      background-color: DarkSeaGreen;
      color: black !important;
    }
    .button-salmon {
      background-color: salmon;
      color: black !important;
    }
    .button-single {
      background-color: violet;
      color: black;
    }
    .button-sim {
      background-color: orange;
      color: black;
    }
    .framed-section2 {
      display: flex;
      align-items: center;
      justify-content: space-around;
      padding: 20px;
      border: 2px solid lightgreen;
      border-radius: 10px;
      background-color: black;
      margin: 10px 0;
    }

  .file-list-container {
    margin: 20px auto; /* Centers the container */
    padding: 15px;
    border: 2px solid lightgreen;
    border-radius: 10px;
    width: 80%; /* Matches the results container */
    max-width: 800px;
    background-color: #222;
    color: white;
    text-align: center; /* Centers the text */
  }
  .file-list-container h3 {
    margin-bottom: 10px;
    font-size: 18px;
    text-align: center;
  }
  #fileList {
    list-style-type: none;
    padding: 0;
    text-align: center;
  }
  #fileList li {
    padding: 5px;
    border-bottom: 1px solid lightgray;
    display: block; /* Ensures filenames appear on new lines */
    width: auto; /* Makes it look more balanced */
  }
  .category-label {
  color: lightgreen !important;
  font-size: 24px !important;
  font-weight: bold !important;
  text-align: center;
  margin-top: 20px;
  display: block;
}

  
  </style>
  <!-- jStat is used for statistical functions -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.5/jstat.min.js"></script>
</head>
<body>
  <div class="container">
    <div>
      <div class="framed-section2">
        <button class="button button-purple" id="howToUseButton">How To Use</button>
        <button class="button button-sim" id="simButton">Simulator</button>
        <button id="viewDataButton" class="button">View Data</button>
        <button id="viewPValueButton" class="button button-DarkSeaGreen">P-Values</button>
        <button id="viewFreqDistButton" class="button button-salmon">Freq Dist</button>
        <button id="viewStatsButton" class="button button-DarkKhaki">Totals</button>
        <button id="densityButton" class="button button-LightSteelBlue">Density</button>
        <button class="button button-single" id="singleSpinButton">Wheel</button>
      </div>
    </div>
    <br />
    <div id="instructionsModal" class="modal">
      <div class="modal-content">
        <button class="close-button" id="closeModalButton">&times;</button>
        <h3>How To Read This Screen</h3>
        <p>...</p>
      </div>
    </div>
  </div>
  <div class="header-container">
    <h1 class="header-text">Stats and Frequency Distribution</h1>
  </div>
  <div class="results-container">
    <input type="file" id="fileInput" accept=".csv" multiple />
    <label for="numRuns">&nbsp;&nbsp;&nbsp;-OR-&nbsp;&nbsp;Enter # of Runs of 38:&nbsp;</label>
    <input type="number" id="numRuns" min="1" max="50000000" value="100" />
    <button id="runButton">Run</button>
    <div id="statistics"></div>
    <div id="explanation"></div>
  </div>
  
  <!-- Add this just before the closing </body> tag -->
<div class="file-list-container">
  <h3>Selected Files:</h3>
  <ul id="fileList"></ul>
</div>

  <script>
    // =======================================================
    // Helper Functions and Global Variables
    // =======================================================
    let totalRuns = 0;
    let selectedFileNames = []; // Store selected filenames globally

    
    // Group indices for various distributions
    const groupIndices = {
      topIndices: [5,22,34,15,3,24,36,13,1,37,27,10,25,29,12,8,19,31,18],
      bottomIndices: [17,32,20,7,11,30,26,9,28,0,2,14,35,23,4,16,33,21,6],
      leftTop: [5,22,34,15,3],
      leftBottom: [17,32,20,7,11],
      rightTop: [12,8,19,31,18],
      rightBottom: [4,16,33,21,6],
      cTop: [24,36,13,1,37,27,10,25,29],
      cBottom: [30,26,9,28,0,2,14,35,23],
      zzCluster: [13,1,37,27,10],
      zCluster: [9,28,0,2,14],
      left: [5,22,34,15,3,24,36,13,1,17,32,20,7,11,30,26,9,28],
      right: [27,10,25,29,12,8,19,31,18,2,14,35,23,4,16,33,21,6],
      towardEnds: [5,22,34,15,3,17,32,20,7,11,12,8,19,31,18,4,16,33,21,6],
      towardCenter: [24,36,13,1,37,27,10,25,29,30,26,9,28,0,2,14,35,23],
      zeroSums: [13,1,37,27,10,9,28,0,2,14]
    };

function sumColumns(counts, indices) {
      return indices.reduce((sum, idx) => sum + counts[idx], 0);
    }
    
// Function to compute Density (sum of top 5 values in a row)
function calculateDensity(counts) {
    return counts
        .slice() // Clone the array to avoid modifying original
        .sort((a, b) => b - a) // Sort in descending order
        .slice(0, 5) // Take top 5
        .reduce((sum, val) => sum + val, 0)
        .toFixed(6); // üî• Trim to 6 decimal places
}

// Function to compute Variance (spread of values in a row)
function calculateVariance(counts) {
    let n = counts.length;
    let mean = counts.reduce((sum, val) => sum + val, 0) / n;
    let variance = counts.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
    return parseFloat(variance.toFixed(6)); // üî• Ensure it's a number with 6 decimal places
}



function calculateAllSums(counts) {
      return {
        topBottomDiff: sumColumns(counts, groupIndices.topIndices) - sumColumns(counts, groupIndices.bottomIndices),
        leftRightDiff: sumColumns(counts, groupIndices.left) - sumColumns(counts, groupIndices.right),
        cDiff: sumColumns(counts, groupIndices.cTop) - sumColumns(counts, groupIndices.cBottom),
        zzDiff: sumColumns(counts, groupIndices.zzCluster) - sumColumns(counts, groupIndices.zCluster),
        topBottomDiff: sumColumns(counts, groupIndices.topIndices) - sumColumns(counts, groupIndices.bottomIndices),
        endsCenterDiff: sumColumns(counts, groupIndices.towardEnds) - sumColumns(counts, groupIndices.towardCenter)
      };	
    }

    // =======================================================
    // Descriptive Statistics & Frequency Functions
    // =======================================================
function calculateDescriptiveStatistics(differences, isVariance = false) {
    if (!Array.isArray(differences) || differences.length === 0) {
        throw new TypeError("The 'differences' argument must be a non-empty array.");
    }

    let n = 0, mean = 0, M2 = 0;
    let min = Infinity, max = -Infinity;
    differences.forEach(x => {
        n++;
        const delta = x - mean;
        const deltaN = delta / n;
        mean += deltaN;
        M2 += delta * (x - mean);
        if (x < min) min = x;
        if (x > max) max = x;
    });

    const variance = M2 / n;
    const stdDev = Math.sqrt(variance);

    return {
        mean: parseFloat(mean.toFixed(4)),  
        variance: parseFloat(variance.toFixed(4)),  
        stdDev: parseFloat(stdDev.toFixed(4)),  
        median: parseFloat(calculateMedian(differences).toFixed(4)),  
        min: parseFloat(min.toFixed(4)),  
        max: parseFloat(max.toFixed(4))
    };
}

// =======================================================
// Ensure referenceData has correct means for categories
// =======================================================
function getExpectedMean(category, isGeneratingReferenceData = false) {
    if (isGeneratingReferenceData) {
        console.log(`üü¢ Skipping expected mean lookup for ${category} since this is a reference data run.`);
        return 0;
    }

    if (referenceData[category]) {
        if (category === "Density" || category === "Variance") {
            console.log(`üü¢ Using expected mean for ${category}:`, referenceData[category]);
            return parseFloat(referenceData[category]?.mean || 0);
        } else if (referenceData[category]["mean"]) {
            return parseFloat(referenceData[category]["mean"]);
        }
    }

    console.warn(`‚ö†Ô∏è No mean found for category: ${category}`);
    return 0;
}


// =======================================================
// Validate Density and Variance values before processing
// =======================================================
function validateDensityAndVariance(densityValues, varianceValues) {
    if (!Array.isArray(densityValues) || densityValues.length === 0) {
        console.error("‚ùå ERROR: Density values array is empty or invalid!");
        densityValues = [0]; // Provide default fallback
    }
    if (!Array.isArray(varianceValues) || varianceValues.length === 0) {
        console.error("‚ùå ERROR: Variance values array is empty or invalid!");
        varianceValues = [0]; // Provide default fallback
    }
    return [densityValues, varianceValues];
}


function calculateMedian(arr) {
    const sorted = arr.slice().sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    
    return sorted.length % 2 !== 0 
        ? parseFloat(sorted[mid].toFixed(4))  // Ensure number, 4 decimal places
        : parseFloat(((sorted[mid - 1] + sorted[mid]) / 2).toFixed(4));  // Ensure number, 4 decimal places
}

// =======================================================
// Fix calculateFrequencyDistribution crashing on undefined
// =======================================================
function calculateFrequencyDistribution(data) {
    if (!Array.isArray(data) || data.length === 0) {
        console.error("‚ùå ERROR: Invalid data provided to calculateFrequencyDistribution");
        return {}; // Return empty object to prevent crash
    }
    const frequency = {};
    data.forEach(val => {
        frequency[val] = (frequency[val] || 0) + 1;
    });
    return frequency;
}

function calculateCumulativeProbabilities(frequencyDistribution, totalValue, category) {
    if (!totalValue || totalValue <= 0) {
        console.error("Invalid total for cumulative probability calculation:", totalValue);
        return {};
    }

    const sortedKeys = Object.keys(frequencyDistribution).map(Number).sort((a, b) => a - b);
    let cumulativeProbabilities = {};
    let cumulativeBelow = 0, cumulativeAbove = 0;

    // üî• Determine expected mean from reference data (if available)
    let expectedMean = referenceData[category]?.mean ? parseFloat(referenceData[category].mean) : 0;
    console.log(`üü¢ Using expected mean for ${category}:`, expectedMean);

    // Split values around expected mean
    let belowMean = sortedKeys.filter(key => key < expectedMean);
    let aboveMean = sortedKeys.filter(key => key > expectedMean);

    // Accumulate probabilities separately
    for (let i = belowMean.length - 1; i >= 0; i--) {
        let key = belowMean[i];
        cumulativeBelow += frequencyDistribution[key];
        cumulativeProbabilities[key] = {
            cumulativeFrequency: cumulativeBelow,
            cumulativeP: (cumulativeBelow / totalValue).toFixed(6)
        };
    }

    for (let i = 0; i < aboveMean.length; i++) {
        let key = aboveMean[i];
        cumulativeAbove += frequencyDistribution[key];
        cumulativeProbabilities[key] = {
            cumulativeFrequency: cumulativeAbove,
            cumulativeP: (cumulativeAbove / totalValue).toFixed(6)
        };
    }

    return cumulativeProbabilities;
}


    // =======================================================
    // Display Functions (Existing)
    // =======================================================
    const categoryLabels = {
      topBottomDiff: "Top - Bottom",
      leftRightDiff: "Left - Right",
      cDiff: "Center 9 Top - Bottom",
      zzDiff: "00 - 0",
      topIndices: "Top",
      bottomIndices: "Bottom",
      leftTop: "Left Top",
      leftBottom: "Left Bottom",
      rightTop: "Right Top",
      rightBottom: "Right Bottom",
      cTop: "Center Top",
      cBottom: "Center Bottom",
      zzCluster: "00 Cluster",
      zCluster: "0 Cluster",
      left: "Left",
      right: "Right",
      towardEnds: "Towards Ends",
      towardCenter: "Towards Center",
      endsCenterDiff: "Towards Ends - Towards Center",
      zeroSums: "Zero Sums Total",
      Density: "Density (Top 5 Sum)",
      Variance: "Variance (Within-Run Spread)"
    };

function displayDescriptiveStatistics(stats) {
      if (!stats || typeof stats !== "object") {
        console.error("Invalid statistics data provided for display.");
        alert("An error occurred while displaying statistics.");
        return;
      }
      const statsElement = document.getElementById("statistics");
      statsElement.innerHTML = `
        <ul>
          <li><strong><span style="color: salmon;"> Mean:</span></strong><strong><span style="color: white;">&nbsp;&nbsp; ${stats.mean}</span></li>
          <li><strong><span style="color: salmon;">Variance:</span></strong><span style="color: white;">&nbsp;&nbsp; ${stats.variance}</span></li>
          <li><strong><span style="color: salmon;">Standard Deviation:</span></strong><span style="color: white;">&nbsp;&nbsp; ${stats.stdDev}</span></li>
          <li><strong><span style="color: salmon;">Median:</span></strong><span style="color: white;">&nbsp;&nbsp; ${stats.median}</span></li>
          <li><strong><span style="color: salmon;">Minimum:</span></strong><span style="color: white;">&nbsp;&nbsp; ${stats.min}</span></li>
          <li><strong><span style="color: salmon;">Maximum:</span></strong><span style="color: white;">&nbsp;&nbsp; ${stats.max}</span></li>
          <li><strong><span style="color: salmon;">Skewness:</span></strong><span style="color: white;">&nbsp;&nbsp; ${stats.skewness}</span></li>
          <li><strong><span style="color: salmon;">Kurtosis:</span></strong><span style="color: white;">&nbsp;&nbsp; ${stats.kurtosis}</span></li>
        </ul>
      `;
    }


    // =======================================================
    // CSV EXPORT FUNCTIONS
    // =======================================================
// =======================================================
// Fix getFreqDistCSV crashing on undefined Density/Variance
// =======================================================
function getFreqDistCSV(differences, groupSums, stats, densityValues, varianceValues) {
    if (!totalRuns || totalRuns <= 0) {
        console.error("Invalid totalRuns for CSV export:", totalRuns);
        return "";
    }

    console.log("üü¢ Density & Variance Passed to CSV:", { densityValues, varianceValues });

    // Validate and assign density and variance values
    [densityValues, varianceValues] = validateDensityAndVariance(densityValues, varianceValues);

    let csvContent = "Category,Metric,Value,,Value,Expected Probability,Observed Frequency,Cumulative Probability,Adjusted P-Value\n";
    const allData = { ...differences, ...groupSums, Density: densityValues, Variance: varianceValues };

    Object.entries(stats).forEach(([category, values]) => {
        const categoryLabel = categoryLabels[category] || category;
        const frequencyDistribution = calculateFrequencyDistribution(allData[category] || []);
        const cumulativeData = calculateCumulativeProbabilities(frequencyDistribution, totalRuns);
        const sortedFrequencyKeys = Object.keys(frequencyDistribution).map(Number).sort((a, b) => a - b);
        const metricKeys = Object.keys(values);
        const maxRows = Math.max(metricKeys.length, sortedFrequencyKeys.length);

        for (let i = 0; i < maxRows; i++) {
            const metric = metricKeys[i] || "";
            let value = metric ? values[metric] : "";

            if ((category === "Variance" || category === "Density") && value !== "") {
                value = parseFloat(value).toFixed(4);
            }

            const difference = sortedFrequencyKeys[i] !== undefined ? sortedFrequencyKeys[i] : "";
            const observedFrequency = difference !== "" ? frequencyDistribution[difference] : "";

            let expectedProbability = "0.000000";
            let cumulativeProbability = "";

            if (difference !== "" && cumulativeData[difference]) {
                cumulativeProbability = (totalRuns > 0 && cumulativeData[difference].cumulativeP)
                    ? Number(cumulativeData[difference].cumulativeP).toFixed(6)
                    : "0.000000";
            }

            // üî• Fix probability lookup from 10mcols.csv
            if (referenceData[categoryLabel] && referenceData[categoryLabel][difference]) {
                expectedProbability = referenceData[categoryLabel][difference].pValue;
                cumulativeProbability = referenceData[categoryLabel][difference].cumulativePValue;
            }

            csvContent += `${categoryLabel},${metric},${value},,${difference},${expectedProbability},${observedFrequency},${cumulativeProbability},\n`;
        }
    });

    return csvContent;
}


// Global object to store reference data from 10mcols.csv
let referenceData = {};
// Call this function once at the beginning
loadReferenceData("10mcols.csv");

// Function to load reference data from 10mcols.csv
function loadReferenceData(csvFilePath) {
    fetch(csvFilePath)
        .then(response => response.text())
        .then(text => {
            const rows = text.split("\n");
            rows.forEach(row => {
                const cols = row.split(",");
                if (cols.length < 4) return; // Ensure row has enough columns

                const category = cols[0].trim();  // Category (index key)
                const difference = cols[1].trim(); // Difference value
                const pValue = cols[2].trim();  // p-Value from 10mcols.csv
                const cumulativePValue = cols[3].trim(); // Cumulative P-Value

                if (!referenceData[category]) {
                    referenceData[category] = {};
                }
                referenceData[category][difference] = { pValue, cumulativePValue };
            });
        })
        .catch(error => console.error("Error loading reference data:", error));
}

function displayResults(differences, groupSums, stats, densityValues, varianceValues) {
    const explanationElement = document.getElementById("explanation");
    explanationElement.innerHTML = "";
    const allCategories = { ...differences, ...groupSums, Density: densityValues, Variance: varianceValues };

    Object.keys(allCategories).forEach(category => {
        if (!stats[category]) return;
        const categoryLabel = categoryLabels[category] || category;

        let categoryHTML = `<h2 class="category-label">${categoryLabel}</h2>`;

        const frequencyDistribution = calculateFrequencyDistribution(allCategories[category]);
        const cumulativeData = calculateCumulativeProbabilities(frequencyDistribution, totalRuns);
        const totalSpins = totalRuns * 38;
        
        let imageLineHTML = `
            <center>
                <span style="color: orange; font-size: 20px; font-weight: bold;">${totalRuns}</span>
                <span style="color: DarkKhaki; font-size: 18px; font-weight: bold;">Runs</span>
                &nbsp;&nbsp;
                <img src="${category}.png" alt="${categoryLabel}" style="max-width: 250px; display: inline-block; margin: 10px auto;">
                &nbsp;&nbsp;
                <span style="color: orange; font-size: 20px; font-weight: bold;">${totalSpins}</span>
                <span style="color: DarkKhaki; font-size: 18px; font-weight: bold;">Spins</span>
            </center><br>`;
            
        let tableHTML = `
            ${categoryHTML}
            ${imageLineHTML}
            <table border='1' style="border-collapse: collapse; width: 100%;">
            <tr>
                <th style="padding: 8px; color: lightgreen; text-align: center;background-color: gray;">Metric</th>
                <th style="padding: 8px; color: lightgreen; text-align: center;background-color: gray;">Value</th>
                <th></th>
                <th style="padding: 8px; color: salmon; text-align: center;">Value</th>
                <th style="padding: 8px; color: salmon; text-align: center;">Expected Probability</th>
                <th style="padding: 8px; color: salmon; text-align: center;">Cumulative Probability</th>
                <th style="padding: 8px; color: salmon; text-align: center;">Observed Frequency</th>
                <th style="padding: 8px; color: salmon; text-align: center;">Adjusted P-Value</th>
            </tr>`;

        const sortedFrequencyKeys = Object.keys(frequencyDistribution).map(Number).sort((a, b) => a - b);
        const metricKeys = Object.keys(stats[category]);
        const maxRows = Math.max(metricKeys.length, sortedFrequencyKeys.length);

        for (let i = 0; i < maxRows; i++) {
            const metric = metricKeys[i] || "";
            let value = metric ? stats[category][metric] : "";

            // üî• Ensure Variance is displayed with exactly 6 decimal places
            if (category === "Variance" && value !== "") {
                value = parseFloat(value).toFixed(4);
            }

            const difference = sortedFrequencyKeys[i] !== undefined ? sortedFrequencyKeys[i] : "";
            const frequency = difference !== "" ? frequencyDistribution[difference] : "";

            let pValue = frequency ? (frequency / totalRuns).toFixed(6) : "";
            let cumulativeFrequency = "";
            let cumulativePValue = "";

            let differenceKey = difference.toString();
            if (difference !== "" && cumulativeData[differenceKey]) {
                cumulativeFrequency = cumulativeData[differenceKey].cumulativeFrequency;
                cumulativePValue = Number(cumulativeData[differenceKey].cumulativeP).toFixed(6);
            }

            if (referenceData[categoryLabel] && referenceData[categoryLabel][differenceKey]) {
                pValue = referenceData[categoryLabel][differenceKey].pValue;
                cumulativePValue = referenceData[categoryLabel][differenceKey].cumulativePValue;
            }

            let metricStyle = "color: orange; font-weight: bold;";
            let valueStyle = "color: lightblue; font-weight: bold;";
            let dataStyle = "color: lightgray;";
            let highlightStyle = "color: yellow; font-weight: bold;";
            let applyHighlight = (cumulativePValue !== "" && parseFloat(cumulativePValue) < 0.05);

            tableHTML += `
            <tr>
                <td style="padding: 8px; text-align: center; ${metricStyle}">${metric}</td>
                <td style="padding: 8px; text-align: center; ${valueStyle}">${value}</td>
                <td style="padding: 8px;"></td>
                <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}">${difference}</td>
                <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}">${pValue}</td>
                <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}">${cumulativePValue}</td>
                <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}">${frequency}</td>
                <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}"></td>
            </tr>`;
        }

        tableHTML += `</table><br/>`;
        explanationElement.innerHTML += tableHTML;
    });
}

function getMaxHitsCSV(maxHits) {
    let csvContent = "Max Hits per Number (Binomial p-values)\n";
    csvContent += "Number,Max Hits Observed,P-Value\n";

    for (let num = 0; num < 38; num++) {
        let k = maxHits[num];
        let pValue = (k > 0) ? (1 - jStat.binomial.cdf(k - 1, 38, 1 / 38)) : 1;

        // üî• Overwrite pValue using reference data (if available)
        let pValueLookup = referenceData["MaxHits"]?.[num.toString()]?.pValue;
        if (pValueLookup !== undefined) {
            pValue = pValueLookup;
        }

        csvContent += `${num},${k},${pValue.toFixed(6)}\n`;
    }

    return csvContent;
}



// =======================================================
// Fix CSV Export to Include Correct Density & Variance
// =======================================================
function exportCombinedCSV(differences, groupSums, stats, maxHits, densityValues, varianceValues, fileName) {
    let csvContent = "";

    console.log("üü¢ Exporting CSV... Checking Density & Variance:", { densityValues, varianceValues });

    csvContent += getFreqDistCSV(differences, groupSums, stats, densityValues, varianceValues);
    csvContent += "\n\n";

    let maxHitsStats = calculateDescriptiveStatistics(maxHits);
    let maxHitsFreq = calculateFrequencyDistribution(maxHits);
    let maxHitsCumulative = calculateCumulativeProbabilities(maxHitsFreq, 38);
    csvContent += getMaxCountsCSV(maxHitsStats, maxHitsFreq, maxHitsCumulative);
    csvContent += "\n\n";
    csvContent += getMaxHitsCSV(maxHits);

    if (selectedFileNames.length > 0) {
        csvContent += "\n\nSelected Files:\n";
        selectedFileNames.forEach(fileName => {
            csvContent += `${fileName}\n`;
        });
    }

 	const encodedUri = "data:text/csv;charset=utf-8," + encodeURIComponent(csvContent) + `#${new Date().getTime()}`;
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", fileName);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}


    

    // =======================================================
    // DISPLAY FUNCTIONS for Max Counts and Max Hits
    // =======================================================
function displayMaxCountsResults(maxHitsStats, maxHitsFreq, maxHitsCumulative) {
      let total = 38;
      let tableHTML = `
        <h3><center><span style="color: orange;">Max Counts</span>
        <br>
        <table border="1" style="border-collapse: collapse; width: 100%;">
          <tr>
            <th style="padding: 8px; color: salmon; text-align: center;">Metric</th>
            <th style="padding: 8px; color: salmon; text-align: center;">Value</th>
            <th style="padding: 8px; color: salmon; text-align: center;">Count</th>
            <th style="padding: 8px; color: salmon; text-align: center;">Frequency</th>
            <th style="padding: 8px; color: salmon; text-align: center;">P-Value</th>
            <th style="padding: 8px; color: salmon; text-align: center;">Cumulative Frequency</th>
            <th style="padding: 8px; color: salmon; text-align: center;">Cumulative Probability</th>
          </tr>`;
      let sortedKeys = Object.keys(maxHitsFreq).map(Number).sort((a, b) => a - b);
      let metricKeys = Object.keys(maxHitsStats);
      let maxRows = Math.max(metricKeys.length, sortedKeys.length);
      for (let i = 0; i < maxRows; i++) {
        const metric = metricKeys[i] || "";
        const formattedMetric = metric ? metric.charAt(0).toUpperCase() + metric.slice(1) : "";
        const value = metric ? maxHitsStats[metric] : "";
        const countValue = sortedKeys[i] !== undefined ? sortedKeys[i] : "";
        const frequency = countValue !== "" ? maxHitsFreq[countValue] : "";
        const pValue = frequency ? (frequency / total).toFixed(6) : "";
        let cumulativeFrequency = "";
        let cumulativePValue = "";
        if (countValue !== "" && maxHitsCumulative[countValue.toString()]) {
          cumulativeFrequency = maxHitsCumulative[countValue.toString()].cumulativeFrequency;
          cumulativePValue = Number(maxHitsCumulative[countValue.toString()].cumulativeP).toFixed(6);
        }
        let metricStyle = "color: orange; font-weight: bold;";
        let valueStyle = "color: lightblue; font-weight: bold;";
        let dataStyle = "color: lightgray;";
        let highlightStyle = "color: yellow; font-weight: bold;";
        let applyHighlight = (cumulativePValue !== "" && parseFloat(cumulativePValue) < 0.05);
        tableHTML += `
          <tr>
            <td style="padding: 8px; text-align: center; ${metricStyle}">${formattedMetric}</td>
            <td style="padding: 8px; text-align: center; ${valueStyle}">${value}</td>
            <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}">${countValue}</td>
            <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}">${frequency}</td>
            <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}">${pValue}</td>
            <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}">${cumulativeFrequency}</td>
            <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}">${cumulativePValue}</td>
          </tr>`;
      }
      tableHTML += `</table><br/>`;
      document.getElementById("explanation").innerHTML += tableHTML;
    }

loadReferenceData("10mcols.csv");

function displayMaxHitsTable(maxHits) {
      let tableHTML = `
        <h3><center><span style="color: orange;">Max Hits per Number</span>
        <span style="color: lightgreen;"> (With Binomial p-values)</span></center></h3>
        <br>
        <table border="1" style="border-collapse: collapse; width: 100%;">
          <tr>
            <th style="padding: 8px; color: salmon; text-align: center;">Number</th>
            <th style="padding: 8px; color: salmon; text-align: center;">Max Hits Observed</th>
            <th style="padding: 8px; color: salmon; text-align: center;">P-Value (P(X ‚â• k))</th>
          </tr>
      `;
      for (let num = 0; num < 38; num++) {
        let k = maxHits[num];
        let pValue = (k > 0) ? (1 - jStat.binomial.cdf(k - 1, 38, 1/38)) : 1;
        let dataStyle = "color: lightgray;";
        let highlightStyle = "color: yellow; font-weight: bold;";
        let applyHighlight = (pValue < 0.05);
        tableHTML += `
          <tr>
            <td style="padding: 8px; text-align: center; color: orange; font-weight: bold;">${num}</td>
            <td style="padding: 8px; text-align: center; color: lightblue; font-weight: bold;">${k}</td>
            <td style="padding: 8px; text-align: center; ${applyHighlight ? highlightStyle : dataStyle}">${pValue.toFixed(6)}</td>
          </tr>
        `;
      }
      tableHTML += `</table><br/>`;
      document.getElementById("explanation").innerHTML += tableHTML;
    }


function getMaxCountsCSV(maxHitsStats, maxHitsFreq, maxHitsCumulative) {
    let csvContent = "Max Counts (Statistical Summary and Frequency Distribution)\n";
    csvContent += "Metric,Value,Count,Expected Frequency,Observed Frequency,Cumulative Probability,Adjusted P-Value\n";

    let sortedKeys = Object.keys(maxHitsFreq).map(Number).sort((a, b) => a - b);
    let metricKeys = Object.keys(maxHitsStats);
    let maxRows = Math.max(metricKeys.length, sortedKeys.length);

    for (let i = 0; i < maxRows; i++) {
        const metric = metricKeys[i] || "";
        const formattedMetric = metric ? metric.charAt(0).toUpperCase() + metric.slice(1) : "";
        const value = metric ? maxHitsStats[metric] : "";
        const countValue = sortedKeys[i] !== undefined ? sortedKeys[i] : "";
        const observedFrequency = countValue !== "" ? maxHitsFreq[countValue] : "";
        let expectedFrequency = observedFrequency ? (observedFrequency / 38).toFixed(6) : "0.000000";
        let adjustedPValue = "";
        let cumulativeProbability = "";

        if (countValue !== "" && maxHitsCumulative[countValue.toString()]) {
            adjustedPValue = maxHitsCumulative[countValue.toString()].cumulativeFrequency;
            cumulativeProbability = Number(maxHitsCumulative[countValue.toString()].cumulativeP).toFixed(6);
        }

        // üî• Overwrite expected frequency and cumulative probability using the reference data üî•
        let expectedFrequencyLookup = referenceData["MaxCounts"]?.[countValue]?.pValue;
        let cumulativeProbabilityLookup = referenceData["MaxCounts"]?.[countValue]?.cumulativePValue;
        if (expectedFrequencyLookup !== undefined) {
            expectedFrequency = expectedFrequencyLookup;
        }
        if (cumulativeProbabilityLookup !== undefined) {
            cumulativeProbability = cumulativeProbabilityLookup;
        }

        csvContent += `${formattedMetric},${value},${countValue},${expectedFrequency},${cumulativeProbability},${adjustedPValue}\n`;
    }

    return csvContent;
}

let dataRows = []; // Global storage to accumulate all generated data

function processChunk(startIndex, chunkSize, isGeneratingReferenceData) {
    let localData = [];  // Use a local array to prevent memory growth

    for (let i = startIndex; i < Math.min(totalRuns, startIndex + chunkSize); i++) {
        const counts = getRandomCounts(38);
        localData.push(counts);
    }

    console.log(`üü¢ Processed chunk: ${startIndex} - ${Math.min(totalRuns, startIndex + chunkSize)}`);

    // Process and discard data from memory
    processData(localData, isGeneratingReferenceData);
    localData = null;  // Free memory

    if (startIndex + chunkSize < totalRuns) {
        setTimeout(() => processChunk(startIndex + chunkSize, chunkSize, isGeneratingReferenceData), 0);
    }
}



function processData(rows, isGeneratingReferenceData = false) {
    console.log("üü¢ Processing Final Data...");

    // ‚úÖ Ensure `rows` is valid
    if (!Array.isArray(rows) || rows.length === 0) {
        console.error("‚ùå ERROR: `rows` is missing or invalid! Aborting processing.");
        return;
    }

    let statsCollection = {};
    const differences = { topBottomDiff: [], leftRightDiff: [], cDiff: [], zzDiff: [] };
    const groupSums = {};
    let densityValues = [];
    let varianceValues = [];

    for (const key in groupIndices) {
        groupSums[key] = [];
    }

    let maxHits = Array(38).fill(0);

    rows.forEach(counts => {
        for (const key in groupIndices) {
            groupSums[key].push(sumColumns(counts, groupIndices[key]));
        }

        const sums = calculateAllSums(counts);
        differences.topBottomDiff.push(sums.topBottomDiff);
        differences.leftRightDiff.push(sums.leftRightDiff);
        differences.cDiff.push(sums.cDiff);
        differences.zzDiff.push(sums.zzDiff);

        let sortedCounts = counts.slice().sort((a, b) => b - a);
        let density = sortedCounts.slice(0, 5).reduce((sum, val) => sum + val, 0);
        densityValues.push(parseFloat(density.toFixed(4)));

        let variance = calculateVariance(counts);
        varianceValues.push(parseFloat(variance.toFixed(4)));

        for (let i = 0; i < 38; i++) {
            if (counts[i] > maxHits[i]) {
                maxHits[i] = counts[i];
            }
        }
    });

    console.log("üü¢ Density Values:", densityValues);
    console.log("üü¢ Variance Values:", varianceValues);

    // ‚úÖ Prevent undefined `densityValues` or `varianceValues`
    [densityValues, varianceValues] = validateDensityAndVariance(densityValues, varianceValues);

    Object.keys(differences).forEach(category => {
        statsCollection[category] = calculateDescriptiveStatistics(differences[category]);
    });

    Object.keys(groupSums).forEach(group => {
        statsCollection[group] = calculateDescriptiveStatistics(groupSums[group]);
    });

    statsCollection["Density"] = calculateDescriptiveStatistics(densityValues);
    statsCollection["Variance"] = calculateDescriptiveStatistics(varianceValues);

    console.log("‚úÖ Data Processed, Displaying Results...");
    
    // ‚úÖ Ensure `statsCollection` is valid before calling `displayResults`
    if (!statsCollection || Object.keys(statsCollection).length === 0) {
        console.error("‚ùå ERROR: `statsCollection` is empty or invalid!");
        return;
    }

    displayResults(differences, groupSums, statsCollection, densityValues, varianceValues);
    exportCombinedCSV(differences, groupSums, statsCollection, maxHits, densityValues, varianceValues, "CombinedAnalysis.csv");
}


    // =======================================================
    // FILE INPUT HANDLING
    // =======================================================
let csvProcessingStarted = false; // Prevent duplicate processing

function processConcatenatedCSVData(csvData) {
  if (csvProcessingStarted) return;
  csvProcessingStarted = true;

  const rows = csvData.trim().split("\n");
  if (rows.length <= 1) {
    alert("The combined CSV data does not contain enough data.");
    csvProcessingStarted = false;
    return;
  }

  const dataRows = [];
  rows.forEach(row => {
    const values = row.split(",").map(value => value.trim());

    // Check if the row is a header
    const isHeader = values.length === 38 && values.every((val, idx) => Number(val) === idx);
    if (isHeader) {
      console.log("Header row detected and skipped:", row);
      return;
    }

    const numericValues = values.map(val => (val === "" || isNaN(val)) ? 0 : Number(val));

    if (numericValues.length === 38) {
      dataRows.push(numericValues);
    }
  });

  totalRuns = dataRows.length; // ‚úÖ FIX: Count actual valid data rows, not all rows
  console.log("Total Runs after filtering headers:", totalRuns);
  processData(dataRows);

  csvProcessingStarted = false;
}


document.getElementById("fileInput").addEventListener("change", function(event) {
    const files = event.target.files;
    let allCSVData = "";
    let filesRead = 0;

    // üü¢ Reset the global array before storing new filenames
    selectedFileNames = [];

    // Get the file list container
    const fileList = document.getElementById("fileList");
    fileList.innerHTML = ""; // Clear the previous list

    if (files.length === 0) {
        alert("No files selected.");
        return;
    }

    for (let i = 0; i < files.length; i++) {
        const file = files[i];

        // üü¢ Store filenames globally for CSV export
        selectedFileNames.push(file.name);

        // Display file name in the list
        const listItem = document.createElement("li");
        listItem.textContent = file.name;
        fileList.appendChild(listItem);

        if (!file || !file.name.endsWith(".csv")) {
            alert(`File "${file.name}" is not a valid .csv file and will be skipped.`);
            filesRead++;
            if (filesRead === files.length) {
                processConcatenatedCSVData(allCSVData);
            }
            continue;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            allCSVData += e.target.result + "\n";
            filesRead++;

            if (filesRead === files.length) {
                console.log("üü¢ Selected Files for CSV Export:", selectedFileNames);
                processConcatenatedCSVData(allCSVData);

                // üü¢ FIX: Reset the file input so it triggers again when re-selected
                document.getElementById("fileInput").value = "";
                
                // üü¢ FIX: Allow new file selections by resetting flag
                csvProcessingStarted = false;
            }
        };
        reader.onerror = function() {
            alert(`Error reading file: ${file.name}`);
            filesRead++;
            if (filesRead === files.length) {
                processConcatenatedCSVData(allCSVData);

                // üü¢ Reset file input after error
                document.getElementById("fileInput").value = "";
                csvProcessingStarted = false;
            }
        };
        reader.readAsText(file);
    }
});


    // =======================================================
    // SIMULATION (Run Button) HANDLER
    // =======================================================
    const setAIndices = [5,22,34,15,3,24,36,13,1,37,27,10,25,29,12,8,19,31,18];
    const setBIndices = [17,32,20,7,11,30,26,9,28,0,2,14,35,23,4,16,33,21,6];

const worker = new Worker("worker.js");

document.getElementById("runButton").addEventListener("click", () => {
    const numRuns = parseInt(document.getElementById("numRuns").value, 10);
    if (isNaN(numRuns) || numRuns < 1 || numRuns > 10000000) {
        alert("Please enter a valid number of runs (1‚Äì10,000,000).");
        return;
    }

    const chunkSize = 100000;
    let allResults = [];

    console.log("Total Runs Set:", numRuns);
    totalRuns = numRuns;  // ‚úÖ Ensure totalRuns is set

    worker.postMessage({ numRuns, chunkSize });

    worker.onmessage = function (e) {
        if (e.data.type === "chunk") {
            allResults.push(...e.data.data);
            console.log(`‚úÖ Received ${e.data.data.length} results, total: ${allResults.length}`);
        } else if (e.data.type === "done") {
            totalRuns = e.data.totalRuns;  // ‚úÖ Ensure totalRuns is set when processing starts
            console.log("‚úÖ All data processed, starting analysis...");
            processData(allResults);
        }
    };

    worker.onerror = function (error) {
        console.error("‚ùå Worker error:", error);
    };
});


// ‚úÖ Function to Detect Incognito Mode
async function detectIncognito() {
    return new Promise(resolve => {
        if (navigator.storage && navigator.storage.estimate) {
            navigator.storage.estimate().then(estimate => {
                resolve(estimate.quota < 120000000); // Quota under 120MB suggests Incognito Mode
            });
        } else {
            resolve(false); // Assume non-incognito if storage API is unavailable
        }
    });
}

// ‚úÖ Function to Run Simulations in a Web Worker
function runSimulationWithWorker(numRuns) {
    const worker = new Worker("worker.js");

    worker.postMessage({ numRuns });

    worker.onmessage = function (e) {
        processData(e.data);
    };

    worker.onerror = function (error) {
        console.error("Worker error:", error);
        alert("Error occurred in Web Worker. Try reducing the number of runs.");
    };
}


function getRandomCounts(numPicks) {
  const counts = Array(38).fill(0);
  for (let i = 0; i < numPicks; i++) {
    const array = new Uint32Array(1);
    window.crypto.getRandomValues(array);
    const pickedNumber = array[0] % 38; // Using crypto RNG instead of Math.random()
    counts[pickedNumber]++;
  }
  return counts;
}


    // =======================================================
    // ADDITIONAL EVENT LISTENERS
    // =======================================================
       	// Event listener for the Simulator button
    	document.getElementById('simButton').addEventListener('click', () => {
        window.open('roulette.html', '_blank');
      });
      
        // New event listener for the View Data button
      	document.getElementById('viewDataButton').addEventListener('click', () => {
        window.open('view-data.html', '_blank');
      });
      
        // New event listener for the View P-Value button
      	document.getElementById('viewPValueButton').addEventListener('click', () => {
        window.open('pvalues.html', '_blank');
      });
      
        // New event listener for the View P-Value button
      	document.getElementById('viewFreqDistButton').addEventListener('click', () => {
        window.open('xfreq.html', '_blank');
      });
       // New event listener for the View Stats button
      	document.getElementById('viewStatsButton').addEventListener('click', () => {
        window.open('view-stats.html', '_blank');
      });

       	// Event listener for the Simulator button
    	document.getElementById('singleSpinButton').addEventListener('click', () => {
        window.open('new-wheel.html', '_blank');
      });
        document.getElementById("densityButton").addEventListener("click", () => { 
        window.open("sort.html", "_blank"); 
      });
          

</script>
</body>
</html>