<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="robots" content="noindex">
<title>Tinnitus Freq Finder (Multi-Layer)</title>
<style>
  :root { --bg:#0f1115; --panel:#171a21; --text:#e6e7e9; --muted:#a9b0bc; --accent:#6ee7ff; --accent2:#8a7bff; --warn:#ffb86b; --danger:#ff6b6b; }
  *{ box-sizing:border-box; }
  html,body{ height:100%; margin:0; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--text); }
  .wrap{ max-width:1100px; margin:24px auto 80px; padding:0 16px; }
  .header{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px; }
  h1{ font-size:26px; margin:0; letter-spacing:0.3px; background: linear-gradient(90deg,var(--accent),var(--accent2)); -webkit-background-clip: text; background-clip: text; color: transparent; }
  .card{ background:var(--panel); border:1px solid #222630; border-radius:16px; padding:16px; margin:14px 0; box-shadow:0 8px 30px rgba(0,0,0,.3); }
  .grid{ display:grid; grid-template-columns: repeat(12, 1fr); gap:14px; }
  .col-12{ grid-column: span 12; }
  .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  label{ font-size:13px; color:var(--muted); }
  input[type="range"]{ width:240px; }
  input[type="number"], select{ width:120px; padding:6px 8px; border-radius:10px; border:1px solid #2a2f3a; background:#0e1117; color:var(--text); }
  .btn{ padding:10px 14px; border-radius:12px; border:1px solid #2a2f3a; background:#0f1320; color:var(--text); cursor:pointer; transition:all .15s; }
  .btn.primary{ background:linear-gradient(135deg,#1b5cff,#21b6ff); border-color:transparent; }
  .btn.warn{ background:linear-gradient(135deg,#ff9f1a,#ff5f6d); border-color:transparent; }
  .btn.tab{ background:linear-gradient(135deg,#1a2030,#101726); border-color:#2f3850; color:#d9f3ff; }
  .btn.tab.active{ background:linear-gradient(135deg,#1b5cff,#21b6ff); color:#0b1020; border-color:transparent; box-shadow:0 10px 24px rgba(33,182,255,.35); }
  .badge{ padding:4px 8px; border-radius:999px; font-size:12px; background:#11161f; border:1px solid #2a2f3a; color:var(--muted); }
  .small{ font-size:12px; color:var(--muted); }
  .hr{ height:1px; background:#232733; margin:12px 0; border-radius:1px; }
  .hidden{ display:none; }
  .led{ width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:8px; background:#24303d; border:1px solid #35465a; box-shadow: inset 0 0 6px rgba(0,0,0,.4); }
  .led.green{ background:#2be38a; box-shadow:0 0 12px rgba(43,227,138,.45); }
  .led.yellow{ background:#ffd166; box-shadow:0 0 12px rgba(255,209,102,.35); }
  .led.red{ background:#ff6b6b; box-shadow:0 0 12px rgba(255,107,107,.35); }
  .toast{ padding:8px 12px; border-radius:10px; border:1px solid #3a2a2a; background:#1a1212; color:#ffb4b4; font-size:12px; }
  .layer-h{ display:flex; align-items:center; gap:10px; margin:2px 0 8px; }
  .layer-h h4{ margin:0; font-size:15px; }

  /* Layer-specific accents */
  .layer1 { --layer-accent:#4ade80; } /* green */
  .layer2 { --layer-accent:#60a5fa; } /* blue  */
  .layer3 { --layer-accent:#f97316; } /* orange*/

  .layer input[type="range"]{ accent-color: var(--layer-accent); }
  .layer .layer-h input[type="checkbox"]{ accent-color: var(--layer-accent); }
  @supports not (accent-color: auto) {
    .layer input[type="range"]{
      -webkit-appearance:none; appearance:none; height:6px; background:#2a2f3a; border-radius:8px;
    }
    .layer input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none; width:16px;height:16px;border-radius:50%;
      background:var(--layer-accent); border:2px solid #0e1117; cursor:pointer;
    }
    .layer input[type="range"]::-moz-range-thumb{
      width:16px;height:16px;border-radius:50%; background:var(--layer-accent);
      border:2px solid #0e1117; cursor:pointer;
    }
    .layer input[type="range"]::-moz-range-track{ height:6px; background:#2a2f3a; border-radius:8px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <h1>🎧 Tinnitus Freq Finder</h1>
    <div class="row">
      <div id="peakLed" class="led"></div>
      <div id="peakText" class="small">Peak OK</div>
      <div class="badge" id="todayBadge">Today: 0 min</div>
      <div class="badge" id="hfPadBadge" style="display:none">HF pad −6 dB</div>
    </div>
  </div>

  <div class="row" style="gap:8px; margin-bottom:10px">
    <button id="tabAppBtn" class="btn tab active">Freq Finder</button>
    <button id="tabGuideBtn" class="btn tab">User Guide</button>
  </div>

  <section id="tabApp" class="tabpage">
    <div class="card">
      <div class="grid">
        <div class="col-12">
          <div class="row">
            <label>Sample rate</label>
            <select id="sr" class="btn">
              <option value="48000" selected>48,000 Hz</option>
              <option value="44100">44,100 Hz</option>
            </select>
            <label>Duration (s)</label>
            <input id="duration" type="number" value="10" min="1" max="1800" step="1" />
            <span class="small">Tip: test with 10–30s; long exports are heavy.</span>
          </div>
        </div>

        <div class="col-12">
          <h3 style="margin:6px 0 8px">Multi-Layer Synth (up to 3 layers)</h3>

          <!-- LAYER 1 -->
          <div class="card layer layer1" style="padding:12px; margin:10px 0">
            <div class="layer-h">
              <input type="checkbox" id="l1_enable" checked />
              <h4>Layer 1</h4>
              <span class="small">Tone + band / cluster</span>
            </div>
            <div class="row">
              <label for="l1_freq">Frequency (Hz)</label>
              <input type="range" id="l1_freq" min="100" max="16000" step="1" value="8000" />
              <input type="number" id="l1_freqNum" min="100" max="22000" step="1" value="8000" />
              <label for="l1_bw">Bandwidth (Hz)</label>
              <input type="range" id="l1_bw" min="0" max="4000" step="10" value="400" />
              <input type="number" id="l1_bwNum" min="0" max="20000" step="10" value="400" />
            </div>
            <div class="row">
              <label for="l1_toneMix">Tone mix</label>
              <input type="range" id="l1_toneMix" min="0" max="1" step="0.01" value="0.6" />
              <input type="number" id="l1_toneMixNum" min="0" max="1" step="0.01" value="0.6" />
              <label for="l1_noiseMix">Noise mix</label>
              <input type="range" id="l1_noiseMix" min="0" max="1" step="0.01" value="0.4" />
              <input type="number" id="l1_noiseMixNum" min="0" max="1" step="0.01" value="0.4" />
              <label for="l1_level">Level</label>
              <input type="range" id="l1_level" min="0" max="1" step="0.01" value="1" />
              <input type="number" id="l1_levelNum" min="0" max="1" step="0.01" value="1" />
            </div>
            <div class="row">
              <label for="l1_color">Noise color</label>
              <select id="l1_color">
                <option value="white" selected>White</option>
                <option value="pink">Pink</option>
                <option value="brown">Brown</option>
              </select>
              <label for="l1_texture">Texture</label>
              <select id="l1_texture">
                <option value="noise" selected>Noise</option>
                <option value="smooth">Smooth hiss</option>
                <option value="hum">Hum</option>
              </select>
              <label for="l1_amHz">AM rate (Hz)</label>
              <input type="range" id="l1_amHz" min="0" max="40" step="0.1" value="0" />
              <input type="number" id="l1_amHzNum" min="0" max="40" step="0.1" value="0" />
              <label for="l1_amDepth">AM depth</label>
              <input type="range" id="l1_amDepth" min="0" max="1" step="0.01" value="0" />
              <input type="number" id="l1_amDepthNum" min="0" max="1" step="0.01" value="0" />
            </div>
          </div>

          <!-- LAYER 2 -->
          <div class="card layer layer2" style="padding:12px; margin:10px 0">
            <div class="layer-h">
              <input type="checkbox" id="l2_enable" />
              <h4>Layer 2</h4>
              <span class="small">Optional 2nd band</span>
            </div>
            <div class="row">
              <label for="l2_freq">Frequency (Hz)</label>
              <input type="range" id="l2_freq" min="100" max="16000" step="1" value="6000" />
              <input type="number" id="l2_freqNum" min="100" max="22000" step="1" value="6000" />
              <label for="l2_bw">Bandwidth (Hz)</label>
              <input type="range" id="l2_bw" min="0" max="4000" step="10" value="1200" />
              <input type="number" id="l2_bwNum" min="0" max="20000" step="10" value="1200" />
            </div>
            <div class="row">
              <label for="l2_toneMix">Tone mix</label>
              <input type="range" id="l2_toneMix" min="0" max="1" step="0.01" value="0.2" />
              <input type="number" id="l2_toneMixNum" min="0" max="1" step="0.01" value="0.2" />
              <label for="l2_noiseMix">Noise mix</label>
              <input type="range" id="l2_noiseMix" min="0" max="1" step="0.01" value="0.8" />
              <input type="number" id="l2_noiseMixNum" min="0" max="1" step="0.01" value="0.8" />
              <label for="l2_level">Level</label>
              <input type="range" id="l2_level" min="0" max="1" step="0.01" value="0.6" />
              <input type="number" id="l2_levelNum" min="0" max="1" step="0.01" value="0.6" />
            </div>
            <div class="row">
              <label for="l2_color">Noise color</label>
              <select id="l2_color">
                <option value="white">White</option>
                <option value="pink" selected>Pink</option>
                <option value="brown">Brown</option>
              </select>
              <label for="l2_texture">Texture</label>
              <select id="l2_texture">
                <option value="noise" selected>Noise</option>
                <option value="smooth">Smooth hiss</option>
                <option value="hum">Hum</option>
              </select>
              <label for="l2_amHz">AM rate (Hz)</label>
              <input type="range" id="l2_amHz" min="0" max="40" step="0.1" value="0" />
              <input type="number" id="l2_amHzNum" min="0" max="40" step="0.1" value="0" />
              <label for="l2_amDepth">AM depth</label>
              <input type="range" id="l2_amDepth" min="0" max="1" step="0.01" value="0" />
              <input type="number" id="l2_amDepthNum" min="0" max="1" step="0.01" value="0" />
            </div>
          </div>

          <!-- LAYER 3 -->
          <div class="card layer layer3" style="padding:12px; margin:10px 0">
            <div class="layer-h">
              <input type="checkbox" id="l3_enable" />
              <h4>Layer 3</h4>
              <span class="small">Optional 3rd band</span>
            </div>
            <div class="row">
              <label for="l3_freq">Frequency (Hz)</label>
              <input type="range" id="l3_freq" min="100" max="16000" step="1" value="3000" />
              <input type="number" id="l3_freqNum" min="100" max="22000" step="1" value="3000" />
              <label for="l3_bw">Bandwidth (Hz)</label>
              <input type="range" id="l3_bw" min="0" max="4000" step="10" value="2000" />
              <input type="number" id="l3_bwNum" min="0" max="20000" step="10" value="2000" />
            </div>
            <div class="row">
              <label for="l3_toneMix">Tone mix</label>
              <input type="range" id="l3_toneMix" min="0" max="1" step="0.01" value="0.0" />
              <input type="number" id="l3_toneMixNum" min="0" max="1" step="0.01" value="0.0" />
              <label for="l3_noiseMix">Noise mix</label>
              <input type="range" id="l3_noiseMix" min="0" max="1" step="0.01" value="1.0" />
              <input type="number" id="l3_noiseMixNum" min="0" max="1" step="0.01" value="1.0" />
              <label for="l3_level">Level</label>
              <input type="range" id="l3_level" min="0" max="1" step="0.01" value="0.4" />
              <input type="number" id="l3_levelNum" min="0" max="1" step="0.01" value="0.4" />
            </div>
            <div class="row">
              <label for="l3_color">Noise color</label>
              <select id="l3_color">
                <option value="white">White</option>
                <option value="pink">Pink</option>
                <option value="brown" selected>Brown</option>
              </select>
              <label for="l3_texture">Texture</label>
              <select id="l3_texture">
                <option value="noise" selected>Noise</option>
                <option value="smooth">Smooth hiss</option>
                <option value="hum">Hum</option>
              </select>
              <label for="l3_amHz">AM rate (Hz)</label>
              <input type="range" id="l3_amHz" min="0" max="40" step="0.1" value="0" />
              <input type="number" id="l3_amHzNum" min="0" max="40" step="0.1" value="0" />
              <label for="l3_amDepth">AM depth</label>
              <input type="range" id="l3_amDepth" min="0" max="1" step="0.01" value="0" />
              <input type="number" id="l3_amDepthNum" min="0" max="1" step="0.01" value="0" />
            </div>
          </div>
        </div>

        <!-- GLOBAL -->
        <div class="col-12">
          <h3 style="margin:6px 0 8px">Global Muffle, Gating & Safety</h3>
          <div class="row">
            <label for="mufFc">Muffle cutoff (Hz)</label>
            <input type="range" id="mufFc" min="0" max="24000" step="50" value="6500" />
            <input type="number" id="mufFcNum" min="0" max="24000" step="10" value="6500" />
            <span class="small">0 = off</span>
            <label for="mufOrder">Muffle order</label>
            <input type="range" id="mufOrder" min="1" max="6" step="1" value="2" />
            <input type="number" id="mufOrderNum" min="1" max="8" step="1" value="2" />
          </div>
          <div class="row">
            <label for="onMs">Slice ON (ms)</label>
            <input type="range" id="onMs" min="0" max="20" step="1" value="0" />
            <input type="number" id="onMsNum" min="0" max="200" step="1" value="0" />
            <label for="offMs">Slice OFF (ms)</label>
            <input type="range" id="offMs" min="0" max="40" step="1" value="0" />
            <input type="number" id="offMsNum" min="0" max="500" step="1" value="0" />
            <span class="small">(Set ON &gt; 0 to enable; OFF can be 0)</span>
            <div id="hpWarn" class="toast hidden">Headphones only recommended when slicing is active.</div>
          </div>
          <div class="row">
            <label for="outDb">Output level</label>
            <input type="range" id="outDb" min="-24" max="-6" step="1" value="-12" />
            <input type="number" id="outDbNum" min="-24" max="-6" step="1" value="-12" />
            <span class="small">dB (capped)</span>
            <label for="route">Routing</label>
            <select id="route" class="btn">
              <option value="stereo" selected>Stereo</option>
              <option value="left">Left-only</option>
              <option value="right">Right-only</option>
            </select>
            <label class="row" style="gap:6px">
              <input type="checkbox" id="hfOverride" />
              <span class="small">Disable HF pad &gt;10 kHz</span>
            </label>
          </div>
          <div class="row small" style="opacity:.85">
            <span class="badge">Shift+Drag</span> for fine control • Live update for layer <b>Freq</b>, <b>BW</b>, <b>Mix/Level</b>, <b>AM</b>, <b>Muffle cutoff</b>, <b>Output</b>. Changes to <b>Texture</b>, <b>Slice</b>, <b>Muffle order</b>, <b>Duration</b> apply on next start.
          </div>
        </div>

        <div class="col-12">
          <div class="row" style="margin-top:10px">
            <button id="playToggleBtn" class="btn primary">▶︎ Play / Monitor</button>
            <div class="hr" style="flex:1"></div>
            <button id="exportBtn" class="btn">⬇︎ Export WAV</button>
            <span class="small">Files include settings in the filename.</span>
          </div>
        </div>

      </div>
    </div>

    <div class="card">
      <h3 style="margin:6px 0 8px">Notes</h3>
      <ul class="small">
        <li><b>Texture</b>: “Noise” = classic filtered noise (grainy); “Smooth hiss” = many micro-sines (fine, steady); “Hum” = few detuned sines (soft, tonal).</li>
        <li>Change <b>Texture</b> then press <b>Stop → Play</b> to rebuild the source (the switch also autostops/plays now).</li>
      </ul>
      <br>
      
      <h3 style="margin:6px 0 8px">How to dial it in</h3>
For soft hum/hiss:<br>
Texture = Smooth hiss, Noise mix ~0.6–0.9, Tone mix ~0.1–0.4, BW ~80–250 Hz.<br>
If you want even silkier: bump K in buildGaussHiss to 96 or 128.<br>
<br>
For a hummier base:<br>
Texture = Hum, BW ~40–120 Hz, Noise mix ~0.6, Tone mix ~0.3.<br><br><br>
    </div>
  </section>

  <section id="tabGuide" class="tabpage hidden">
  
  <div class="card">
  <h2 id="pitch-anchor-sweep">Pitch-Anchor Sweep (Quick Method)</h2>

  <h3>Setup (one time for anchoring)</h3>
  <ul>
    <li><b>Layer 1 only</b>: enabled.</li>
    <li><b>Tone mix</b> = <code>1.00</code>, <b>Noise mix</b> = <code>0.00</code> (pure sine).</li>
    <li><b>Level</b> modest (e.g., <code>0.5–0.7</code>).</li>
    <li><b>BW</b> can stay at <code>0</code> (only affects noise/hum; with Noise mix = 0 it’s irrelevant).</li>
    <li><b>AM depth</b> = <code>0</code>, <b>Muffle</b> off, <b>Slice</b> off.</li>
    <li><b>Route</b> to the ear with the louder tinnitus.</li>
  </ul>

  <h3>Sweep</h3>
  <ol>
    <li><b>Coarse sweep</b> around your expected region (e.g., ~<code>2.6 kHz</code>):<br>
      Start at <code>1 kHz</code>, then jump to <code>1.5 → 2.0 → 2.3 → 2.6 → 2.9 → 3.2 → 3.5 → 4.0 kHz</code>.<br>
      Listen for where the external tone seems to “sit inside” your tinnitus and beating/roughness is minimal.
    </li>
    <li><b>Zoom in</b> around the best spot:<br>
      Use ~<code>100 Hz</code> steps (e.g., <code>2400, 2500, 2600, 2700</code>).<br>
      Then <code>10 Hz</code> steps (e.g., <code>2580–2620</code>).<br>
      Use <kbd>Shift</kbd>+drag for fine control.
    </li>
    <li><b>Micro-tune</b> if needed:<br>
      Use <code>1–2 Hz</code> nudges to land on the “least beating / most fused” point.<br>
      That number is your center <b>f<sub>0</sub></b>.
    </li>
  </ol>

  <h3>Only after you’ve got f<sub>0</sub>…</h3>
  <ul>
    <li>Bring <b>Noise mix</b> up (e.g., <code>0.3–0.8</code>) and pick <b>Texture</b> (“Smooth hiss” for fine hiss, “Hum” for soft tonality).</li>
    <li>Now <b>BW</b> matters — open BW until the <i>character</i> (hiss/hum body) matches your tinnitus.</li>
    <li>Report four numbers to the team: <br>
      <code>low = f<sub>0</sub> − BW/2</code>, <code>center = f<sub>0</sub></code>, <code>high = f<sub>0</sub> + BW/2</code>, <code>width = BW</code>.
    </li>
  </ul>

  <h3>Key clarifications</h3>
  <ul>
    <li>Don’t set both <b>Tone</b> and <b>Noise</b> to <code>0</code> — you won’t hear anything. For anchoring, use <b>Tone=1</b>, <b>Noise=0</b>.</li>
    <li>You don’t need to repeat the sweep with <b>BW=10</b> or <b>20</b> for anchoring; BW only matters once you add noise/hum to shape the body.</li>
    <li>Keep volume low and stable during the sweep; avoid just after shower/exercise/meditation to reduce short-term shifts.</li>
  </ul>
</div>

      <h2>Tinnitus Freq Finder — User Guide</h2>
      <h3>0) What it is</h3>
      <ul>
        <li>Plays a <b>tone + band‑limited noise</b> centered at your chosen frequency</li>
        <li>Adds optional <b>muffle</b> (treble roll‑off)</li>
        <li>Adds optional <b>slice/gating</b> (ON/OFF ms) for choppy/raspy percepts</li>
        <li>Exports <b>16‑bit WAV</b> files you can use elsewhere</li>
      </ul>
      <hr class="hr" />

      <h3>1) Setup (60 seconds)</h3>
      <ol>
        <li>Open this page in <b>Chrome</b> or <b>Edge</b>. Safari/Firefox usually work, but can be slower with long renders.</li>
        <li>Use decent headphones/earbuds or monitors. <b>Start at low volume.</b></li>
      </ol>
      <p class="small"><i>Browsers block auto‑play. You must click <b>Play / Monitor</b> to hear anything.</i></p>

      <h3>2) Quick Start (2 minutes)</h3>
      <ol>
        <li>Set <b>Sample rate</b> (48,000 Hz is fine).</li>
        <li>Set <b>Duration</b> (10–30 s for testing; render longer only when exporting).</li>
        <li>Set <b>Frequency</b> near your perceived tone (e.g., 8000 Hz).</li>
        <li>Set <b>Bandwidth</b>: 0–400 narrow/clean; 600–1200 broader/muffled; >1500 hissier.</li>
        <li>Adjust <b>Tone mix</b> vs <b>Noise mix</b> (auto‑normalized): tonal 0.7/0.3; muffled 0.3/0.7.</li>
        <li>If dull/muffled, enable <b>Muffle</b>: cutoff 5–7 kHz, order 2–4.</li>
        <li>If choppy/raspy, enable <b>Slice</b>: try <b>ON 2 ms / OFF 8 ms</b>.</li>
        <li>Click <b>Play / Monitor</b>. The button turns red <b>Stop</b> while playing and flips back when done.</li>
        <li>When it blends with your tinnitus best, click <b>Export WAV</b>.</li>
      </ol>

      <h3>3) Controls Cheat Sheet</h3>
      <ul>
        <li><b>Frequency (Hz)</b>: center pitch.</li>
        <li><b>Bandwidth (Hz)</b>: width around the center (≈ <code>Q = f0 / BW</code>). Bigger = noisier.</li>
        <li><b>Tone/Noise mix</b>: relative weights (keeps overall level sane).</li>
        <li><b>Muffle</b>: smooth high‑frequency roll‑off; higher order = more “under a pillow.”</li>
        <li><b>Slice ON/OFF (ms)</b>: amplitude gating; ON>0 enables it. Duty ≈ <code>ON / (ON+OFF)</code>.</li>
        <li><b>Duration</b>: playback length and export length.</li>
      </ul>
      <p class="small">Fine control: <b>Shift+drag</b> sliders.</p>

      <h3>4) Recommended Starting Presets</h3>
      <ul>
        <li><b>Clean, tonal</b>: Freq≈guess; BW 200–400; Tone 0.7 / Noise 0.3; Muffle off; Slice off.</li>
        <li><b>Muffled</b>: BW 600–1200; Tone 0.3 / Noise 0.7; Muffle cutoff 5–7 kHz, Order 2–4; Slice off.</li>
        <li><b>Choppy/raspy</b>: Start from “Muffled,” then Slice <b>2/8 ms</b>. Try 3/7, 4/6, 1/9 if 2/8 isn’t right.</li>
        <li><b>Very high‑pitch hiss</b>: Freq near your pitch; BW 1200–2000; Tone 0.2 / Noise 0.8; Muffle cutoff 7–10 kHz, Order 1–2.</li>
      </ul>

      <h3>5) Finding a Perceptual Match (fast workflow)</h3>
      <ol>
        <li><b>Coarse pass</b>: sweep Frequency (±5–10%), BW at 400, 800, 1200.</li>
        <li><b>Character pass</b>: adjust Tone/Noise and Muffle to get timbre right.</li>
        <li><b>Texture pass</b>: if choppy, add Slice (start 2/8 ms) and tweak ON/OFF.</li>
        <li>Export a 30–60 s candidate. If it still matches, export therapy length.</li>
      </ol>

      <h3>6) Exporting WAVs</h3>
      <ul>
        <li>16‑bit PCM mono at chosen sample rate.</li>
        <li>Very long renders (10–30 min) can be heavy. If it fails, export a short loop and stitch it in a DAW.</li>
        <li>Filenames encode all settings.</li>
      </ul>

      <h3>7) Troubleshooting</h3>
      <ul>
        <li><b>No sound</b>: you must click Play / Monitor; also check tab/system volume.</li>
        <li><b>Distortion</b>: turn down output; the app has headroom but your DAC can still clip.</li>
        <li><b>Export fails</b>: reduce Duration; export a short loop and stitch in a DAW.</li>
        <li><b>Firefox sluggish</b>: use Chrome/Edge.</li>
        <li><b>iOS</b>: use a desktop browser for exporting long files.</li>
      </ul>

      <h3>8) Safety & Protocol</h3>
      <ul>
        <li><b>Volume</b>: start low. Don’t blast your ears.</li>
        <li><b>Trial rules</b>: follow your study protocol; don’t upload files to a device if it violates the agreement.</li>
        <li>This tool is <b>not</b> a medical device—just an audio lab.</li>
      </ul>
      <p class="small">Runs locally in your browser; no network calls or analytics.</p>

      <h3>9) Built‑in Safety Features (what the app enforces)</h3>
      <ul>
        <li><b>Output cap</b>: master output slider is limited to <span class="mono">−24…−6 dBFS</span>. Exports use the same cap.</li>
        <li><b>Limiter</b>: a fast dynamics limiter after the master catches brief transients around <span class="mono">≈ −6 dBFS</span>.</li>
        <li><b>Soft start/stop</b>: 300 ms fade‑in/out to avoid thumps.</li>
        <li><b>HF pad</b>: automatic <span class="mono">−6 dB</span> padding when <b>Frequency</b> &gt; 10 kHz (badge shows). You can override with “Disable HF pad &gt;10 kHz.”</li>
        <li><b>Peak monitor + auto‑backoff</b>: LED + live dBFS readout. If the peak approaches <span class="mono">−1 dBFS</span>, the app reduces output by <span class="mono">3 dB</span> automatically.</li>
        <li><b>Panic stop</b>: press <b>Space</b> or <b>Esc</b> to stop immediately.</li>
        <li><b>Ear routing</b>: Stereo / Left‑only / Right‑only so you can favor one ear if your protocol calls for it.</li>
        <li><b>Click‑train caution</b>: when <b>Slice</b> is enabled the app shows a headphones warning; keep volumes conservative because gating creates sharper transients.</li>
        <li><b>Session time badge</b>: the header shows <b>Today: X/Y min</b> with color cues and prompts at 75% & 100% of your chosen budget. (Not SPL‑calibrated.)</li>
      </ul>
      <p class="small">Limitations: the app cannot control your system/device volume and is not a dosimeter. Peak dBFS is not the same as ear‑canal dB SPL.</p>

      <h3>9) Built‑in Safety Features (what the app enforces)</h3>
      <ul>
        <li><b>Output cap</b>: master output slider is limited to <span class="mono">−24…−6 dBFS</span>. Exports use the same cap.</li>
        <li><b>Limiter</b>: a fast dynamics limiter after the master catches brief transients around <span class="mono">≈ −6 dBFS</span>.</li>
        <li><b>Soft start/stop</b>: 300 ms fade‑in/out to avoid thumps.</li>
        <li><b>HF pad</b>: automatic <span class="mono">−6 dB</span> padding when <b>Frequency</b> &gt; 10 kHz (badge shows). You can override with “Disable HF pad &gt;10 kHz.”</li>
        <li><b>Peak monitor + auto‑backoff</b>: LED + live dBFS readout. If the peak approaches <span class="mono">−1 dBFS</span>, the app reduces output by <span class="mono">3 dB</span> automatically.</li>
        <li><b>Panic stop</b>: press <b>Space</b> or <b>Esc</b> to stop immediately.</li>
        <li><b>Ear routing</b>: Stereo / Left‑only / Right‑only so you can favor one ear if your protocol calls for it.</li>
        <li><b>Click‑train caution</b>: when <b>Slice</b> is enabled the app shows a headphones warning; keep volumes conservative because gating creates sharper transients.</li>
        <li><b>Session time badge</b>: the header shows <b>Today: X min</b> so you can tally daily exposure time. (Not SPL‑calibrated.)</li>
      </ul>
      <p class="small">Limitations: the app cannot control your system/device volume and is not a dosimeter. Peak dBFS is not the same as ear‑canal dB SPL.</p>
    </div>
  </section>
</div>

<script>
(function(){
  'use strict';

  // -------- DOM helpers --------
  const $ = (id) => document.getElementById(id);

  // Tabs
  const tabAppBtn = $('tabAppBtn');
  const tabGuideBtn = $('tabGuideBtn');
  const tabApp = $('tabApp');
  const tabGuide = $('tabGuide');
  function showTab(which){ const app = which==='app'; tabApp.classList.toggle('hidden',!app); tabGuide.classList.toggle('hidden',app); tabAppBtn.classList.toggle('active',app); tabGuideBtn.classList.toggle('active',!app); }
  tabAppBtn.addEventListener('click',()=>showTab('app'));
  tabGuideBtn.addEventListener('click',()=>showTab('guide'));

  // Header bits
  const peakLed = $('peakLed');
  const peakText = $('peakText');
  const todayBadge = $('todayBadge');
  const hfPadBadge = $('hfPadBadge');
  const hpWarn = $('hpWarn');

  // Controls
  const sr = $('sr'), duration = $('duration'),
        mufFc = $('mufFc'), mufFcNum = $('mufFcNum'),
        mufOrder = $('mufOrder'), mufOrderNum = $('mufOrderNum'),
        onMs = $('onMs'), onMsNum = $('onMsNum'),
        offMs = $('offMs'), offMsNum = $('offMsNum'),
        outDb = $('outDb'), outDbNum = $('outDbNum'),
        route = $('route'), hfOverride = $('hfOverride'),
        playToggleBtn = $('playToggleBtn'), exportBtn = $('exportBtn');

  const lin=(db)=>Math.pow(10,db/20);
  const clamp=(v,lo,hi)=>Math.min(hi,Math.max(lo,v));

  function todayKey(){ const d=new Date(); return d.toISOString().slice(0,10); }
  function getTodayMinutes(){ const key='minutes_'+todayKey(); return +(localStorage.getItem(key)||'0'); }
  function addTodayMinutes(min){ const key='minutes_'+todayKey(); const cur=getTodayMinutes(); localStorage.setItem(key,String(cur+min)); renderToday(); }
  function renderToday(){ todayBadge.textContent = `Today: ${getTodayMinutes().toFixed(1)} min`; }
  renderToday();

  // Layer DOM bundles
  function layerDom(i){
    return {
      enable: $('l'+i+'_enable'),
      freq: $('l'+i+'_freq'),
      freqNum: $('l'+i+'_freqNum'),
      bw: $('l'+i+'_bw'),
      bwNum: $('l'+i+'_bwNum'),
      toneMix: $('l'+i+'_toneMix'),
      toneMixNum: $('l'+i+'_toneMixNum'),
      noiseMix: $('l'+i+'_noiseMix'),
      noiseMixNum: $('l'+i+'_noiseMixNum'),
      level: $('l'+i+'_level'),
      levelNum: $('l'+i+'_levelNum'),
      color: $('l'+i+'_color'),
      texture: $('l'+i+'_texture'),
      amHz: $('l'+i+'_amHz'),
      amHzNum: $('l'+i+'_amHzNum'),
      amDepth: $('l'+i+'_amDepth'),
      amDepthNum: $('l'+i+'_amDepthNum')
    };
  }
  const L=[layerDom(1),layerDom(2),layerDom(3)];

  // Link helpers
  function linkPair(rangeEl,numEl,{min=null,max=null}={}){
    const sync=(src,dst)=>{ dst.value=src.value; };
    rangeEl.addEventListener('input',()=>{ sync(rangeEl,numEl); scheduleApply(); });
    numEl.addEventListener('input',()=>{
      if(min!==null) numEl.value=Math.max(min,+numEl.value);
      if(max!==null) numEl.value=Math.min(max,+numEl.value);
      sync(numEl,rangeEl); scheduleApply();
    });
    sync(rangeEl,numEl);
  }
  function bindTypingFreq(layer){
    const MIN=100, MAX=22000;
    layer.freq.addEventListener('input',()=>{ layer.freqNum.value=layer.freq.value; scheduleApply(); });
    layer.freqNum.addEventListener('input',()=>{
      const v=parseFloat(layer.freqNum.value);
      if(Number.isFinite(v)&&v>=MIN&&v<=MAX){ layer.freq.value=String(v); scheduleApply(); }
    });
    const commit=()=>{
      let v=parseFloat(layer.freqNum.value); if(!Number.isFinite(v)) v=+layer.freq.value||8000;
      v=clamp(v,MIN,MAX); layer.freqNum.value=String(v); layer.freq.value=String(v); scheduleApply();
    };
    layer.freqNum.addEventListener('change',commit);
    layer.freqNum.addEventListener('blur',commit);
    layer.freqNum.addEventListener('keydown',e=>{ if(e.key==='Enter'){ commit(); layer.freqNum.blur(); } });
    layer.freqNum.value=layer.freq.value;
  }

  L.forEach(layer=>{
    bindTypingFreq(layer);
    linkPair(layer.bw,layer.bwNum,{min:0,max:20000});
    linkPair(layer.toneMix,layer.toneMixNum,{min:0,max:1});
    linkPair(layer.noiseMix,layer.noiseMixNum,{min:0,max:1});
    linkPair(layer.level,layer.levelNum,{min:0,max:1});
    linkPair(layer.amHz,layer.amHzNum,{min:0,max:40});
    linkPair(layer.amDepth,layer.amDepthNum,{min:0,max:1});
    layer.color.addEventListener('change',scheduleApply);
    layer.texture.addEventListener('change', async ()=>{ if(liveCtx){ await stop(); await play(); } }); // rebuild graph
    layer.enable.addEventListener('change',scheduleApply);
  });

  // Global binds
  (function linkMuf(){
    const MIN=0, MAX=24000;
    mufFc.addEventListener('input',()=>{ mufFcNum.value=mufFc.value; scheduleApply(); });
    const commit=()=>{
      let v=parseFloat(mufFcNum.value); if(!Number.isFinite(v)) v=6500;
      v=clamp(v,MIN,MAX); mufFcNum.value=String(v); mufFc.value=String(v); scheduleApply();
    };
    mufFcNum.addEventListener('change',commit);
    mufFcNum.addEventListener('blur',commit);
    mufFcNum.addEventListener('keydown',e=>{ if(e.key==='Enter'){ commit(); mufFcNum.blur(); } });
    mufFcNum.value=mufFc.value;
  })();
  linkPair(mufOrder,mufOrderNum,{min:1,max:8});
  onMs.addEventListener('input',()=>{ onMsNum.value=onMs.value; });
  onMsNum.addEventListener('input',()=>{ onMs.value=onMsNum.value; });
  offMs.addEventListener('input',()=>{ offMsNum.value=offMs.value; });
  offMsNum.addEventListener('input',()=>{ offMs.value=offMsNum.value; });
  linkPair(outDb,outDbNum,{min:-24,max:-6});
  route.addEventListener('change',scheduleApply);
  hfOverride.addEventListener('change',scheduleApply);

  function getParams(){
    const layers=L.map(layer=>{
      const t=+layer.toneMixNum.value, n=+layer.noiseMixNum.value; const s=Math.max(1e-9,t+n);
      return {
        enable:layer.enable.checked,
        freq:Math.max(100,+layer.freqNum.value),
        bw:Math.max(0,+layer.bwNum.value),
        toneMix:t/s, noiseMix:n/s,
        level:clamp(+layer.levelNum.value,0,1),
        color:layer.color.value,
        texture:layer.texture.value,
        amHz:Math.max(0,+layer.amHzNum.value),
        amDepth:clamp(+layer.amDepthNum.value,0,1)
      };
    });
    const anyHigh=layers.some(l=>l.enable&&l.freq>10000);
    const hfPadActive=anyHigh&&!hfOverride.checked;
    hfPadBadge.style.display=hfPadActive?'inline-block':'none';
    hpWarn.classList.toggle('hidden', !(+onMsNum.value>0));
    return {
      sr:+sr.value, duration:Math.max(0.1,+duration.value),
      layers,
      mufFc:Math.max(0,+mufFcNum.value),
      mufOrder:Math.max(1,Math.round(+mufOrderNum.value)),
      onMs:Math.max(0,+onMsNum.value), offMs:Math.max(0,+offMsNum.value),
      outDb:Math.min(-6,Math.max(-24,+outDbNum.value)),
      route:route.value, hfPad:hfPadActive?0.5:1.0
    };
  }

  // ---------- Audio graph helpers ----------
  function noiseBuffer(ctx, seconds=8){
    const buf=ctx.createBuffer(1,Math.max(1,Math.floor(ctx.sampleRate*seconds)),ctx.sampleRate);
    const d=buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; return buf;
  }
  function colorNode(ctx,color){
    if(color==='white'){ return new GainNode(ctx,{gain:1}); }
    if(color==='pink'){ return new BiquadFilterNode(ctx,{type:'lowshelf',frequency:1000,gain:-9}); }
    return new BiquadFilterNode(ctx,{type:'lowpass',frequency:1000,Q:0.707}); // brown
  }
// --- NEW: tiny Gaussian RNG for micro-sines
function randn() { // Box–Muller, mean 0, std 1
  let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
}

// Few detuned sines for a soft HUM (symmetric, weighted)
function buildHumCluster(ctx, f0, bw, K){
  const group = new GainNode(ctx, { gain: 1 });
  const partials = [];
  for(let k=0;k<K;k++){
    const pos = (K===1)?0:(-1 + 2*k/(K-1));      // -1..1
    const delta = (bw/2)*pos;                     // Hz offset
    const weight = Math.exp(-2.5*pos*pos);        // center emphasis
    const osc = new OscillatorNode(ctx, { type:'sine', frequency:f0+delta });
    const g   = new GainNode(ctx, { gain: 0 });
    osc.connect(g).connect(group);
    // tiny random start jitter to decorrelate phases
    const jit = Math.random()*0.003; // 0..3 ms
    osc.start(ctx.currentTime + jit);
    partials.push({ osc, gain:g, pos, weight, kind:'hum' });
  }
  // normalize weights
  const sum = partials.reduce((s,p)=>s+p.weight,0);
  partials.forEach(p=> p.weight /= sum);
  return { group, partials };
}

// Many micro-sines drawn from a true Gaussian around f0 (FWHM = BW)
function buildGaussHiss(ctx, f0, bw, K){
  const sr = ctx.sampleRate;
  const nyq = sr/2;
  const sigma = Math.max(1, bw||1) / 2.355; // FWHM→σ
  const group = new GainNode(ctx, { gain: 1 });
  const partials = [];
  for(let k=0;k<K;k++){
    const z = randn();                         // ~N(0,1)
    let f = f0 + z * sigma;                    // Hz
    f = Math.max(20, Math.min(nyq-50, f));     // clamp
    const osc = new OscillatorNode(ctx, { type:'sine', frequency:f });
    const g   = new GainNode(ctx, { gain: 0 }); // per-partial gain set later
    osc.connect(g).connect(group);
    const jit = Math.random()*0.003;           // 0..3 ms start jitter
    osc.start(ctx.currentTime + jit);
    // equal nominal weight; Gaussian shape comes from frequency distribution
    partials.push({ osc, gain:g, z, weight: 1, kind:'gauss' });
  }
  // normalize equal weights to sum=1
  const norm = 1/Math.max(1,partials.length);
  partials.forEach(p=> p.weight = norm);
  return { group, partials };
}
  // ---------- buildGraph (this is the one you were missing) ----------
  function buildGraph(ctx,p,forOffline=false){
    const preMuffleMix=new GainNode(ctx,{gain:1});
    const layerNodes=[]; const baseNoise=noiseBuffer(ctx,8);

    for(let i=0;i<p.layers.length;i++){
      const Lp=p.layers[i];
      // Tone
      const osc=new OscillatorNode(ctx,{type:'sine',frequency:Lp.freq});
      const toneGain=new GainNode(ctx,{gain: Lp.enable?(Lp.level*Lp.toneMix):0});
      osc.connect(toneGain);

      // Texture branch: classic noise or cluster (smooth/hum)
      let noise=null,color=null,bp=null, noiseGain;
      let cluster=null; let texture=Lp.texture;
      noiseGain=new GainNode(ctx,{gain: Lp.enable?(Lp.level*Lp.noiseMix):0});

      if(texture==='noise'){
        noise=new AudioBufferSourceNode(ctx,{buffer:baseNoise,loop:true});
        color=colorNode(ctx,Lp.color);
        const q=Math.max(0.0001, Lp.bw>0 ? (Lp.freq/Math.max(1,Lp.bw)) : 0.0001);
        bp=new BiquadFilterNode(ctx,{type:'bandpass',frequency:Lp.freq,Q:q});
        noise.connect(color).connect(bp).connect(noiseGain);
        noise.start();
} else {
  if (texture === 'hum') {
    const K = 5; // few partials = soft tonal body
    cluster = buildHumCluster(ctx, Lp.freq, Math.max(1, Lp.bw||1), K);
  } else { // 'smooth' => true Gaussian micro-sine cloud
    const K = 128; // increase to 96/128 if your CPU is comfy
    cluster = buildGaussHiss(ctx, Lp.freq, Math.max(1, Lp.bw||1), K);
  }
  cluster.group.connect(noiseGain);
}

      // Sum tone + (noise/cluster)
      const layerSum=new GainNode(ctx,{gain:1});
      toneGain.connect(layerSum); noiseGain.connect(layerSum);

      // AM
      const amGain=new GainNode(ctx,{gain:1});
      layerSum.connect(amGain);
      const depth=Lp.amDepth||0;
      const amScale=new GainNode(ctx,{gain:depth/2});
      const amOffset=new ConstantSourceNode(ctx,{offset:1 - depth/2});
      amOffset.connect(amGain.gain); amOffset.start();
      const amOsc=new OscillatorNode(ctx,{type:'sine',frequency:Math.max(0.0001, Lp.amHz||0.0001)});
      amOsc.connect(amScale).connect(amGain.gain); amOsc.start();

      amGain.connect(preMuffleMix);
      osc.start();

      layerNodes.push({osc,toneGain,noise,color,bp,noiseGain,layerSum,amGain,amOsc,amScale,amOffset, texture, cluster});
    }

    // Global muffle
    let chainHead=preMuffleMix; const lpChain=[];
    if(p.mufFc>0){
      for(let i=0;i<p.mufOrder;i++){
        const lp=new BiquadFilterNode(ctx,{type:'lowpass',frequency:p.mufFc,Q:0.707});
        chainHead.connect(lp); chainHead=lp; lpChain.push(lp);
      }
    }

    // Global slicing gate
    const gate=new GainNode(ctx,{gain:1.0});
    chainHead.connect(gate);
    function scheduleGate(){
      if(p.onMs<=0){ gate.gain.setValueAtTime(1.0,0); return; }
      const on=p.onMs/1000, off=p.offMs/1000, period=Math.max(1e-4,on+off);
      const total=p.duration; let t=0; gate.gain.cancelScheduledValues(0);
      while(t<total){ gate.gain.setValueAtTime(1.0,t); const tOff=t+on; if(tOff<=total){ gate.gain.setValueAtTime(0.0,tOff); } t+=period; }
    }

    // Master + limiter
    const master=new GainNode(ctx,{gain:0.0});
    const limiter=new DynamicsCompressorNode(ctx,{threshold:-6,knee:30,ratio:20,attack:0.003,release:0.25});
    gate.connect(master).connect(limiter);

    // Routing
    let routeNodes=null;
    if(forOffline){ limiter.connect(ctx.destination); }
    else{
      const leftGain=new GainNode(ctx,{gain:1});
      const rightGain=new GainNode(ctx,{gain:1});
      const merger=new ChannelMergerNode(ctx,{numberOfInputs:2});
      limiter.connect(leftGain); limiter.connect(rightGain);
      leftGain.connect(merger,0,0); rightGain.connect(merger,0,1);
      merger.connect(ctx.destination);
      routeNodes={leftGain,rightGain};
    }

    function setMasterTarget(db,pad){ master.gain.setTargetAtTime(Math.max(0, lin(db)*pad), ctx.currentTime, 0.03); }
    function start(at=0){ scheduleGate(); setMasterTarget(p.outDb,p.hfPad); master.gain.setValueAtTime(0.0,at); master.gain.linearRampToValueAtTime(Math.max(0,lin(p.outDb)*p.hfPad), at+0.3); }
    function stop(at){
      try{
        master.gain.cancelScheduledValues(at); master.gain.linearRampToValueAtTime(0.0, at+0.3);
        for(const ln of layerNodes){
          try{ ln.osc.stop(at+0.35); }catch(_){}
          if(ln.noise){ try{ ln.noise.stop(at+0.35); }catch(_){ } }
          if(ln.cluster && ln.cluster.partials){ for(const prt of ln.cluster.partials){ try{ prt.osc.stop(at+0.35); }catch(_){} } }
        }
      }catch(_){}
    }

    return { start, stop, nodes:{layerNodes,lpChain,gate,master,limiter,routeNodes} };
  }

  // ---------- Live playback ----------
  let liveCtx=null, liveCtrl=null, liveNodes=null, liveStopTimer=null, peakProcessor=null, sessionStart=null, tickTimer=null;

  function setRoute(which){ if(!liveNodes||!liveNodes.routeNodes) return;
    if(which==='left'){ liveNodes.routeNodes.leftGain.gain.value=1; liveNodes.routeNodes.rightGain.gain.value=0; }
    else if(which==='right'){ liveNodes.routeNodes.leftGain.gain.value=0; liveNodes.routeNodes.rightGain.gain.value=1; }
    else { liveNodes.routeNodes.leftGain.gain.value=1; liveNodes.routeNodes.rightGain.gain.value=1; }
  }
  function updatePeakUI(level){
    const dbfs=20*Math.log10(Math.max(level,1e-9));
    peakText.textContent=`Peak ${dbfs.toFixed(1)} dBFS`;
    peakLed.classList.remove('green','yellow','red');
    if(level<0.5) peakLed.classList.add('green'); else if(level<0.89) peakLed.classList.add('yellow'); else peakLed.classList.add('red');
  }
  function attachPeakProcessor(ctx,sourceNode){
    const proc=ctx.createScriptProcessor(2048,1,1);
    sourceNode.connect(proc); proc.connect(ctx.destination);
    proc.onaudioprocess=(e)=>{
      const ch=e.inputBuffer.getChannelData(0); let peak=0; for(let i=0;i<ch.length;i++){ const a=Math.abs(ch[i]); if(a>peak) peak=a; }
      updatePeakUI(peak);
      if(peak>=0.89){ const curDb=+outDbNum.value; const newDb=Math.max(-24,curDb-3); if(newDb<curDb){ outDbNum.value=String(newDb); outDb.value=outDbNum.value; applyLiveParams(); } }
    };
    return proc;
  }
  function updatePlayButton(playing){
    const btn=playToggleBtn;
    if(playing){ btn.textContent='■ Stop'; btn.classList.remove('primary'); btn.classList.add('warn'); }
    else { btn.textContent='▶︎ Play / Monitor'; btn.classList.remove('warn'); btn.classList.add('primary'); }
  }

  async function play(){
    if(liveCtx){ await stop(); }
    const p=getParams();
    liveCtx=new (window.AudioContext||window.webkitAudioContext)({sampleRate:p.sr});
    liveCtrl=buildGraph(liveCtx,p);
    liveNodes=liveCtrl.nodes; setRoute(p.route);
    peakProcessor=attachPeakProcessor(liveCtx, liveNodes.limiter);
    liveCtrl.start(liveCtx.currentTime);
    updatePlayButton(true);
    sessionStart=performance.now();
    clearTimeout(liveStopTimer); clearInterval(tickTimer);
    liveStopTimer=setTimeout(()=>{ stop(); }, p.duration*1000+120);
    tickTimer=setInterval(()=>{ renderToday(); }, 5000);
  }
  async function stop(){
    if(!liveCtx) return;
    try{ const t=liveCtx.currentTime; liveCtrl?.stop(t); }catch(_){}
    await new Promise(r=>setTimeout(r,380));
    try{ peakProcessor?.disconnect(); }catch(_){}
    try{ liveCtx.close(); }catch(_){}
    if(sessionStart){ const mins=(performance.now()-sessionStart)/60000; if(mins>0){ addTodayMinutes(mins); } }
    liveCtx=null; liveCtrl=null; liveNodes=null; peakProcessor=null; sessionStart=null;
    clearTimeout(liveStopTimer); clearInterval(tickTimer);
    updatePlayButton(false);
  }
  async function togglePlay(){ if(liveCtx){ await stop(); } else { await play(); } }
  playToggleBtn.addEventListener('click',togglePlay);
  document.addEventListener('keydown',e=>{ if(e.code==='Space'||e.code==='Escape'){ e.preventDefault(); stop(); } });

  // Live param updates
  function applyLiveParams(){
    if(!liveCtx||!liveNodes) return; const p=getParams();
    try{
      for(let i=0;i<liveNodes.layerNodes.length;i++){
        const N=liveNodes.layerNodes[i]; const Lp=p.layers[i];
        // Tone
        N.osc.frequency.setTargetAtTime(Lp.freq, liveCtx.currentTime, 0.01);
        N.toneGain.gain.setTargetAtTime(Lp.enable?(Lp.level*Lp.toneMix):0, liveCtx.currentTime, 0.02);

        // Texture branch
        if(N.texture==='noise'){
          if(N.bp){
            N.bp.frequency.setTargetAtTime(Lp.freq, liveCtx.currentTime, 0.01);
            const q=Math.max(0.0001, Lp.bw>0 ? (Lp.freq/Math.max(1,Lp.bw)) : 0.0001);
            N.bp.Q.setTargetAtTime(q, liveCtx.currentTime, 0.01);
          }
          if(N.color){
            if(N.color.type==='lowshelf'){ N.color.gain.setTargetAtTime((Lp.color==='pink')?-9:(Lp.color==='brown'?-15:0), liveCtx.currentTime, 0.02); }
            if(N.color.type==='lowpass'){ N.color.frequency.setTargetAtTime((Lp.color==='brown')?1000:20000, liveCtx.currentTime, 0.02); }
          }
} else if (N.cluster && N.cluster.partials) {
  const baseGain = Lp.enable ? (Lp.level * Lp.noiseMix) : 0;
  const bw = Math.max(1, Lp.bw||1);
  const sigma = bw / 2.355;
  for (const prt of N.cluster.partials) {
    // Use stored shape info:
    // hum: deterministic symmetric offsets via prt.pos
    // gauss: stochastic offsets via prt.z (Normal 0..1)
    const offset = (prt.kind === 'hum') ? (prt.pos * (bw/2))
                                        : (prt.z * sigma);
    const f = Lp.freq + offset;
    prt.osc.frequency.setTargetAtTime(f, liveCtx.currentTime, 0.01);
    prt.gain.gain.setTargetAtTime(baseGain * prt.weight, liveCtx.currentTime, 0.02);
  }
}

        // Overall “noise/cluster” loudness here (single place)
        N.noiseGain.gain.setTargetAtTime(Lp.enable?(Lp.level*Lp.noiseMix):0, liveCtx.currentTime, 0.02);

        // AM
        const depth=Lp.amDepth||0;
        N.amScale.gain.setTargetAtTime(depth/2, liveCtx.currentTime, 0.02);
        N.amOffset.offset.setTargetAtTime(1 - depth/2, liveCtx.currentTime, 0.02);
        N.amOsc.frequency.setTargetAtTime(Math.max(0.0001,Lp.amHz||0.0001), liveCtx.currentTime, 0.02);
      }
      if(liveNodes.lpChain && liveNodes.lpChain.length){
        for(const lp of liveNodes.lpChain){ lp.frequency.setTargetAtTime(Math.max(20, p.mufFc||20000), liveCtx.currentTime, 0.02); }
      }
      const target=Math.max(0, lin(p.outDb)*p.hfPad);
      liveNodes.master.gain.setTargetAtTime(target, liveCtx.currentTime, 0.03);
      setRoute(p.route);
    }catch(_){}
  }
  let rafPending=false; function scheduleApply(){ if(!liveCtx) return; if(rafPending) return; rafPending=true; requestAnimationFrame(()=>{ rafPending=false; applyLiveParams(); }); }
  [mufFc,mufFcNum,outDb,outDbNum,route,hfOverride].forEach(el=>el.addEventListener('input',scheduleApply));
  ;[onMs,onMsNum,mufOrder,mufOrderNum,duration].forEach(el=>el.addEventListener('input',()=>{}));

  // ---------- Export ----------
  function floatToWavBlob(chData,sr){
    const numFrames=chData.length; const buffer=new ArrayBuffer(44+numFrames*2); const view=new DataView(buffer);
    const WS=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); };
    WS(0,'RIFF'); view.setUint32(4,36+numFrames*2,true); WS(8,'WAVE'); WS(12,'fmt '); view.setUint32(16,16,true);
    view.setUint16(20,1,true); view.setUint16(22,1,true); view.setUint32(24,sr,true); view.setUint32(28,sr*2,true);
    view.setUint16(32,2,true); view.setUint16(34,16,true); WS(36,'data'); view.setUint32(40,numFrames*2,true);
    let off=44; for(let i=0;i<numFrames;i++){ const s=Math.max(-1,Math.min(1,chData[i]*0.98)); view.setInt16(off, s<0 ? s*0x8000 : s*0x7FFF, true); off+=2; }
    return new Blob([view],{type:'audio/wav'});
  }
  async function exportWav(){
    const p0=getParams();
    if(p0.duration>1800){ alert('Please keep duration ≤ 1800s (30 min).'); return; }
    const offCtx=new OfflineAudioContext(1, Math.ceil(p0.sr*p0.duration), p0.sr);
    const ctrl=buildGraph(offCtx,p0,true); ctrl.start(0);
    const rendered=await offCtx.startRendering();
    const ch=rendered.getChannelData(0);
    let peak=0; for(let i=0;i<ch.length;i++){ const a=Math.abs(ch[i]); if(a>peak) peak=a; }
    if(peak>0.98){ alert('Export peaked too high; lowering output 3 dB and retry.'); outDbNum.value=String(Math.max(-24,+outDbNum.value-3)); outDb.value=outDbNum.value; return exportWav(); }
    const blob=floatToWavBlob(ch,p0.sr);
    function layerTag(Lp,idx){
      if(!Lp.enable) return `L${idx}off`;
      return `L${idx}f${Math.round(Lp.freq)}bw${Math.round(Lp.bw)}t${Lp.toneMix.toFixed(2)}n${Lp.noiseMix.toFixed(2)}lvl${Lp.level.toFixed(2)}_${Lp.color}_${Lp.texture}_am${(+Lp.amHz).toFixed(1)}x${(+Lp.amDepth).toFixed(2)}`;
    }
    const layersPart=p0.layers.map((Lx,i)=>layerTag(Lx,i+1)).join('__');
    const tag=`${layersPart}_muf${Math.round(p0.mufFc)}o${p0.mufOrder}_slice${Math.round(p0.onMs)}x${Math.round(p0.offMs)}_${p0.duration}s_${p0.sr}sr_out${p0.outDb}dB${p0.hfPad<1?'_HFpad':''}`;
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`tinnitus_${tag}.wav`; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),5000);
  }
  exportBtn.addEventListener('click',exportWav);
})();
</script>
</body>
</html>


