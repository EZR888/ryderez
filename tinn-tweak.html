tinn-tweak.html<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex">
  <title>Tinnitus Freq Finder (Multi‚ÄëLayer)</title>
  <style>
    :root { --bg:#0f1115; --panel:#171a21; --text:#e6e7e9; --muted:#a9b0bc; --accent:#6ee7ff; --accent2:#8a7bff; --warn:#ffb86b; --danger:#ff6b6b; }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--text); }
    .wrap{ max-width:1100px; margin:24px auto 80px; padding:0 16px; }
    .header{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px; }
    h1{ font-size:26px; margin:0; letter-spacing:0.3px; background: linear-gradient(90deg,var(--accent),var(--accent2)); -webkit-background-clip: text; background-clip: text; color: transparent; }
    .card{ background:var(--panel); border:1px solid #222630; border-radius:16px; padding:16px; margin:14px 0; box-shadow:0 8px 30px rgba(0,0,0,.3); }
    .grid{ display:grid; grid-template-columns: repeat(12, 1fr); gap:14px; }
    .col-4{ grid-column: span 4; }
    .col-6{ grid-column: span 6; }
    .col-8{ grid-column: span 8; }
    .col-12{ grid-column: span 12; }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    label{ font-size:13px; color:var(--muted); }
    input[type="range"]{ width: 240px; }
    input[type="number"], select{ width: 120px; padding:6px 8px; border-radius:10px; border:1px solid #2a2f3a; background:#0e1117; color:var(--text); }
    .btn{ padding:10px 14px; border-radius:12px; border:1px solid #2a2f3a; background:#0f1320; color:var(--text); cursor:pointer; transition: all .15s ease; }
    .btn:hover{ transform: translateY(-1px); border-color:#394253; }
    .btn.primary{ background: linear-gradient(135deg, #1b5cff, #21b6ff); border-color: transparent; }
    .btn.warn{ background: linear-gradient(135deg, #ff9f1a, #ff5f6d); border-color:transparent; }
    .btn.tab{ background: linear-gradient(135deg, #1a2030, #101726); border-color:#2f3850; color:#d9f3ff; box-shadow:0 0 0 rgba(0,0,0,0); }
    .btn.tab:hover{ box-shadow: 0 0 0 2px rgba(110,231,255,.25); }
    .btn.tab.active{ background: linear-gradient(135deg, #1b5cff, #21b6ff); color:#0b1020; border-color: transparent; box-shadow: 0 10px 24px rgba(33,182,255,.35); }
    .badge{ padding:4px 8px; border-radius:999px; font-size:12px; background:#11161f; border:1px solid #2a2f3a; color:var(--muted); }
    .small{ font-size:12px; color:var(--muted); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .hr{ height:1px; background:#232733; margin:12px 0; border-radius:1px; }
    .hidden{ display:none; }
    .led{ width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:8px; background:#24303d; border:1px solid #35465a; box-shadow: inset 0 0 6px rgba(0,0,0,.4); }
    .led.green{ background:#2be38a; box-shadow:0 0 12px rgba(43,227,138,.45); }
    .led.yellow{ background:#ffd166; box-shadow:0 0 12px rgba(255,209,102,.35); }
    .led.red{ background:#ff6b6b; box-shadow:0 0 12px rgba(255,107,107,.35); }
    .toast{ padding:8px 12px; border-radius:10px; border:1px solid #3a2a2a; background:#1a1212; color:#ffb4b4; font-size:12px; }
    .layer-h{ display:flex; align-items:center; gap:10px; margin:2px 0 8px; }
    .layer-h h4{ margin:0; font-size:15px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <h1>üéß Tinnitus Freq Finder</h1>
    <div class="row">
      <div id="peakLed" class="led"></div>
      <div id="peakText" class="small">Peak OK</div>
      <div class="badge" id="todayBadge">Today: 0 min</div>
      <div class="badge" id="hfPadBadge" style="display:none">HF pad ‚àí6 dB</div>
    </div>
  </div>

  <div class="row" style="gap:8px; margin-bottom:10px">
    <button id="tabAppBtn" class="btn tab active">Freq Finder</button>
    <button id="tabGuideBtn" class="btn tab">User Guide</button>
  </div>

  <!-- TAB: APP -->
  <section id="tabApp" class="tabpage">
    <div class="card">
      <div class="grid">
        <div class="col-12">
          <div class="row">
            <label>Sample rate</label>
            <select id="sr" class="btn">
              <option value="48000" selected>48,000 Hz</option>
              <option value="44100">44,100 Hz</option>
            </select>
            <label>Duration (s)</label>
            <input id="duration" type="number" value="10" min="1" max="1800" step="1" />
            <span class="small">Tip: test with 10‚Äì30s; long exports are heavy.</span>
          </div>
        </div>

        <!-- MULTI-LAYER CONTROLS -->
        <div class="col-12">
          <h3 style="margin:6px 0 8px">Multi‚ÄëLayer Synth (up to 3 layers)</h3>
          
          <!-- LAYER 1 -->
          <div class="card" style="padding:12px; margin:10px 0">
            <div class="layer-h">
              <input type="checkbox" id="l1_enable" checked />
              <h4>Layer 1</h4>
              <span class="small">Tone + band‚Äëlimited noise</span>
            </div>
            <div class="row">
              <label for="l1_freq">Frequency (Hz)</label>
              <input type="range" id="l1_freq" min="100" max="16000" step="1" value="8000" />
              <input type="number" id="l1_freqNum" min="100" max="22000" step="1" value="8000" />
              <label for="l1_bw">Bandwidth (Hz)</label>
              <input type="range" id="l1_bw" min="0" max="4000" step="10" value="400" />
              <input type="number" id="l1_bwNum" min="0" max="20000" step="10" value="400" />
            </div>
            <div class="row">
              <label for="l1_toneMix">Tone mix</label>
              <input type="range" id="l1_toneMix" min="0" max="1" step="0.01" value="0.6" />
              <input type="number" id="l1_toneMixNum" min="0" max="1" step="0.01" value="0.6" />
              <label for="l1_noiseMix">Noise mix</label>
              <input type="range" id="l1_noiseMix" min="0" max="1" step="0.01" value="0.4" />
              <input type="number" id="l1_noiseMixNum" min="0" max="1" step="0.01" value="0.4" />
              <label for="l1_level">Level</label>
              <input type="range" id="l1_level" min="0" max="1" step="0.01" value="1" />
              <input type="number" id="l1_levelNum" min="0" max="1" step="0.01" value="1" />
            </div>
            <div class="row">
              <label for="l1_color">Noise color</label>
              <select id="l1_color">
                <option value="white" selected>White</option>
                <option value="pink">Pink</option>
                <option value="brown">Brown</option>
              </select>
              <label for="l1_amHz">AM rate (Hz)</label>
              <input type="range" id="l1_amHz" min="0" max="40" step="0.1" value="0" />
              <input type="number" id="l1_amHzNum" min="0" max="40" step="0.1" value="0" />
              <label for="l1_amDepth">AM depth</label>
              <input type="range" id="l1_amDepth" min="0" max="1" step="0.01" value="0" />
              <input type="number" id="l1_amDepthNum" min="0" max="1" step="0.01" value="0" />
            </div>
          </div>

          <!-- LAYER 2 -->
          <div class="card" style="padding:12px; margin:10px 0">
            <div class="layer-h">
              <input type="checkbox" id="l2_enable" />
              <h4>Layer 2</h4>
              <span class="small">Optional 2nd band</span>
            </div>
            <div class="row">
              <label for="l2_freq">Frequency (Hz)</label>
              <input type="range" id="l2_freq" min="100" max="16000" step="1" value="6000" />
              <input type="number" id="l2_freqNum" min="100" max="22000" step="1" value="6000" />
              <label for="l2_bw">Bandwidth (Hz)</label>
              <input type="range" id="l2_bw" min="0" max="4000" step="10" value="1200" />
              <input type="number" id="l2_bwNum" min="0" max="20000" step="10" value="1200" />
            </div>
            <div class="row">
              <label for="l2_toneMix">Tone mix</label>
              <input type="range" id="l2_toneMix" min="0" max="1" step="0.01" value="0.2" />
              <input type="number" id="l2_toneMixNum" min="0" max="1" step="0.01" value="0.2" />
              <label for="l2_noiseMix">Noise mix</label>
              <input type="range" id="l2_noiseMix" min="0" max="1" step="0.01" value="0.8" />
              <input type="number" id="l2_noiseMixNum" min="0" max="1" step="0.01" value="0.8" />
              <label for="l2_level">Level</label>
              <input type="range" id="l2_level" min="0" max="1" step="0.01" value="0.6" />
              <input type="number" id="l2_levelNum" min="0" max="1" step="0.01" value="0.6" />
            </div>
            <div class="row">
              <label for="l2_color">Noise color</label>
              <select id="l2_color">
                <option value="white">White</option>
                <option value="pink" selected>Pink</option>
                <option value="brown">Brown</option>
              </select>
              <label for="l2_amHz">AM rate (Hz)</label>
              <input type="range" id="l2_amHz" min="0" max="40" step="0.1" value="0" />
              <input type="number" id="l2_amHzNum" min="0" max="40" step="0.1" value="0" />
              <label for="l2_amDepth">AM depth</label>
              <input type="range" id="l2_amDepth" min="0" max="1" step="0.01" value="0" />
              <input type="number" id="l2_amDepthNum" min="0" max="1" step="0.01" value="0" />
            </div>
          </div>

          <!-- LAYER 3 -->
          <div class="card" style="padding:12px; margin:10px 0">
            <div class="layer-h">
              <input type="checkbox" id="l3_enable" />
              <h4>Layer 3</h4>
              <span class="small">Optional 3rd band</span>
            </div>
            <div class="row">
              <label for="l3_freq">Frequency (Hz)</label>
              <input type="range" id="l3_freq" min="100" max="16000" step="1" value="3000" />
              <input type="number" id="l3_freqNum" min="100" max="22000" step="1" value="3000" />
              <label for="l3_bw">Bandwidth (Hz)</label>
              <input type="range" id="l3_bw" min="0" max="4000" step="10" value="2000" />
              <input type="number" id="l3_bwNum" min="0" max="20000" step="10" value="2000" />
            </div>
            <div class="row">
              <label for="l3_toneMix">Tone mix</label>
              <input type="range" id="l3_toneMix" min="0" max="1" step="0.01" value="0.0" />
              <input type="number" id="l3_toneMixNum" min="0" max="1" step="0.01" value="0.0" />
              <label for="l3_noiseMix">Noise mix</label>
              <input type="range" id="l3_noiseMix" min="0" max="1" step="0.01" value="1.0" />
              <input type="number" id="l3_noiseMixNum" min="0" max="1" step="0.01" value="1.0" />
              <label for="l3_level">Level</label>
              <input type="range" id="l3_level" min="0" max="1" step="0.01" value="0.4" />
              <input type="number" id="l3_levelNum" min="0" max="1" step="0.01" value="0.4" />
            </div>
            <div class="row">
              <label for="l3_color">Noise color</label>
              <select id="l3_color">
                <option value="white">White</option>
                <option value="pink">Pink</option>
                <option value="brown" selected>Brown</option>
              </select>
              <label for="l3_amHz">AM rate (Hz)</label>
              <input type="range" id="l3_amHz" min="0" max="40" step="0.1" value="0" />
              <input type="number" id="l3_amHzNum" min="0" max="40" step="0.1" value="0" />
              <label for="l3_amDepth">AM depth</label>
              <input type="range" id="l3_amDepth" min="0" max="1" step="0.01" value="0" />
              <input type="number" id="l3_amDepthNum" min="0" max="1" step="0.01" value="0" />
            </div>
          </div>
        </div>

        <!-- GLOBAL TIMBRE / SAFETY -->
        <div class="col-12">
          <h3 style="margin:6px 0 8px">Global Muffle, Gating & Safety</h3>
          <div class="row">
            <label for="mufFc">Muffle cutoff (Hz)</label>
            <input type="range" id="mufFc" min="0" max="24000" step="50" value="6500" />
            <input type="number" id="mufFcNum" min="0" max="24000" step="10" value="6500" />
            <span class="small">0 = off</span>
            <label for="mufOrder">Muffle order</label>
            <input type="range" id="mufOrder" min="1" max="6" step="1" value="2" />
            <input type="number" id="mufOrderNum" min="1" max="8" step="1" value="2" />
          </div>
          <div class="row">
            <label for="onMs">Slice ON (ms)</label>
            <input type="range" id="onMs" min="0" max="20" step="1" value="0" />
            <input type="number" id="onMsNum" min="0" max="200" step="1" value="0" />
            <label for="offMs">Slice OFF (ms)</label>
            <input type="range" id="offMs" min="0" max="40" step="1" value="0" />
            <input type="number" id="offMsNum" min="0" max="500" step="1" value="0" />
            <span class="small">(Set ON &gt; 0 to enable; OFF can be 0)</span>
            <div id="hpWarn" class="toast hidden">Headphones only recommended when slicing is active.</div>
          </div>
          <div class="row">
            <label for="outDb">Output level</label>
            <input type="range" id="outDb" min="-24" max="-6" step="1" value="-12" />
            <input type="number" id="outDbNum" min="-24" max="-6" step="1" value="-12" />
            <span class="small">dB (capped)</span>

            <label for="route">Routing</label>
            <select id="route" class="btn">
              <option value="stereo" selected>Stereo</option>
              <option value="left">Left-only</option>
              <option value="right">Right-only</option>
            </select>

            <label class="row" style="gap:6px">
              <input type="checkbox" id="hfOverride" />
              <span class="small">Disable HF pad &gt;10 kHz</span>
            </label>
          </div>
          <div class="row small" style="opacity:.85">
            <span class="badge">Shift+Drag</span> for fine control ‚Ä¢ Live update for layer <b>Freq</b>, <b>BW</b>, <b>Mix/Level</b>, <b>AM</b>, <b>Muffle cutoff</b>, <b>Output</b>. Changes to <b>Slice</b>, <b>Muffle order</b>, <b>Duration</b> apply on next start.
          </div>
        </div>

        <div class="col-12">
          <div class="row" style="margin-top:10px">
            <button id="playToggleBtn" class="btn primary">‚ñ∂Ô∏é Play / Monitor</button>
            <div class="hr" style="flex:1"></div>
            <button id="exportBtn" class="btn">‚¨áÔ∏é Export WAV</button>
            <span class="small">Files include settings in the filename.</span>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3 style="margin:6px 0 8px">Notes</h3>
      <ul class="small">
        <li>Each layer is a tone + band‚Äëlimited noise centered at its frequency, with optional AM (amplitude modulation) for roughness.</li>
        <li><b>Noise color</b> tilts spectrum: White = flat, Pink ‚âà ‚àí6 dB/Oct, Brown ‚âà ‚àí12 dB/Oct (approximate via shelf/low‚Äëpass).</li>
        <li><b>Muffle</b> chains low‚Äëpass filters after mixing to roll off treble; higher order ‚áí more muffled.</li>
        <li><b>Slice</b> is global gating: ON &gt; 0ms enables click‚Äëtrain style bursts (headphones recommended).</li>
        <li>Very long exports (10‚Äì30 min) are heavy; if it fails, export 30‚Äì60s and loop in a DAW.</li>
      </ul>
    </div>
  </section>

  <!-- TAB: GUIDE (short) -->
  <section id="tabGuide" class="tabpage hidden">
    <div class="card">
      <h2>Quick Guide</h2>
      <ol>
        <li>Enable Layer 1 and sweep its <b>Frequency</b> to your dominant pitch.</li>
        <li>Use <b>Bandwidth</b> + <b>Noise color</b> to get the hiss/body right, then set <b>Level</b>.</li>
        <li>Add Layers 2/3 for extra bands (e.g., humming floor or additional tone).</li>
        <li>Use global <b>Muffle</b> and optional <b>Slice</b> for treble roll‚Äëoff and texture.</li>
        <li>Keep volumes conservative; safety caps, limiter, and HF pad are active.</li>
      </ol>
    </div>

    <div class="card">
      <h2>User Guide</h2>
      <h3>0) What it is</h3>
      <ul>
        <li>Plays a <b>tone + band‚Äëlimited noise</b> centered at your chosen frequency</li>
        <li>Adds optional <b>muffle</b> (treble roll‚Äëoff)</li>
        <li>Adds optional <b>slice/gating</b> (ON/OFF ms) for choppy/raspy percepts</li>
        <li>Exports <b>16‚Äëbit WAV</b> files you can use elsewhere</li>
      </ul>
      <hr class="hr" />

      <h3>1) Setup (60 seconds)</h3>
      <ol>
        <li>Open this page in <b>Chrome</b> or <b>Edge</b>. Safari/Firefox usually work, but can be slower with long renders.</li>
        <li>Use decent headphones/earbuds or monitors. <b>Start at low volume.</b></li>
      </ol>
      <p class="small"><i>Browsers block auto‚Äëplay. You must click <b>Play / Monitor</b> to hear anything.</i></p>

      <h3>2) Quick Start (2 minutes)</h3>
      <ol>
        <li>Set <b>Sample rate</b> (48,000 Hz is fine).</li>
        <li>Set <b>Duration</b> (10‚Äì30 s for testing; render longer only when exporting).</li>
        <li>Set <b>Frequency</b> near your perceived tone (e.g., 8000 Hz).</li>
        <li>Set <b>Bandwidth</b>: 0‚Äì400 narrow/clean; 600‚Äì1200 broader/muffled; >1500 hissier.</li>
        <li>Adjust <b>Tone mix</b> vs <b>Noise mix</b> (auto‚Äënormalized): tonal 0.7/0.3; muffled 0.3/0.7.</li>
        <li>If dull/muffled, enable <b>Muffle</b>: cutoff 5‚Äì7 kHz, order 2‚Äì4.</li>
        <li>If choppy/raspy, enable <b>Slice</b>: try <b>ON 2 ms / OFF 8 ms</b>.</li>
        <li>Click <b>Play / Monitor</b>. The button turns red <b>Stop</b> while playing and flips back when done.</li>
        <li>When it blends with your tinnitus best, click <b>Export WAV</b>.</li>
      </ol>

      <h3>3) Controls Cheat Sheet</h3>
      <ul>
        <li><b>Frequency (Hz)</b>: center pitch.</li>
        <li><b>Bandwidth (Hz)</b>: width around the center (‚âà <code>Q = f0 / BW</code>). Bigger = noisier.</li>
        <li><b>Tone/Noise mix</b>: relative weights (keeps overall level sane).</li>
        <li><b>Muffle</b>: smooth high‚Äëfrequency roll‚Äëoff; higher order = more ‚Äúunder a pillow.‚Äù</li>
        <li><b>Slice ON/OFF (ms)</b>: amplitude gating; ON>0 enables it. Duty ‚âà <code>ON / (ON+OFF)</code>.</li>
        <li><b>Duration</b>: playback length and export length.</li>
      </ul>
      <p class="small">Fine control: <b>Shift+drag</b> sliders.</p>

      <h3>4) Recommended Starting Presets</h3>
      <ul>
        <li><b>Clean, tonal</b>: Freq‚âàguess; BW 200‚Äì400; Tone 0.7 / Noise 0.3; Muffle off; Slice off.</li>
        <li><b>Muffled</b>: BW 600‚Äì1200; Tone 0.3 / Noise 0.7; Muffle cutoff 5‚Äì7 kHz, Order 2‚Äì4; Slice off.</li>
        <li><b>Choppy/raspy</b>: Start from ‚ÄúMuffled,‚Äù then Slice <b>2/8 ms</b>. Try 3/7, 4/6, 1/9 if 2/8 isn‚Äôt right.</li>
        <li><b>Very high‚Äëpitch hiss</b>: Freq near your pitch; BW 1200‚Äì2000; Tone 0.2 / Noise 0.8; Muffle cutoff 7‚Äì10 kHz, Order 1‚Äì2.</li>
      </ul>

      <h3>5) Finding a Perceptual Match (fast workflow)</h3>
      <ol>
        <li><b>Coarse pass</b>: sweep Frequency (¬±5‚Äì10%), BW at 400, 800, 1200.</li>
        <li><b>Character pass</b>: adjust Tone/Noise and Muffle to get timbre right.</li>
        <li><b>Texture pass</b>: if choppy, add Slice (start 2/8 ms) and tweak ON/OFF.</li>
        <li>Export a 30‚Äì60 s candidate. If it still matches, export therapy length.</li>
      </ol>

      <h3>6) Exporting WAVs</h3>
      <ul>
        <li>16‚Äëbit PCM mono at chosen sample rate.</li>
        <li>Very long renders (10‚Äì30 min) can be heavy. If it fails, export a short loop and stitch it in a DAW.</li>
        <li>Filenames encode all settings.</li>
      </ul>

      <h3>7) Troubleshooting</h3>
      <ul>
        <li><b>No sound</b>: you must click Play / Monitor; also check tab/system volume.</li>
        <li><b>Distortion</b>: turn down output; the app has headroom but your DAC can still clip.</li>
        <li><b>Export fails</b>: reduce Duration; export a short loop and stitch in a DAW.</li>
        <li><b>Firefox sluggish</b>: use Chrome/Edge.</li>
        <li><b>iOS</b>: use a desktop browser for exporting long files.</li>
      </ul>

      <h3>8) Safety & Protocol</h3>
      <ul>
        <li><b>Volume</b>: start low. Don‚Äôt blast your ears.</li>
        <li><b>Trial rules</b>: follow your study protocol; don‚Äôt upload files to a device if it violates the agreement.</li>
        <li>This tool is <b>not</b> a medical device‚Äîjust an audio lab.</li>
      </ul>
      <p class="small">Runs locally in your browser; no network calls or analytics.</p>

      <h3>9) Built‚Äëin Safety Features (what the app enforces)</h3>
      <ul>
        <li><b>Output cap</b>: master output slider is limited to <span class="mono">‚àí24‚Ä¶‚àí6 dBFS</span>. Exports use the same cap.</li>
        <li><b>Limiter</b>: a fast dynamics limiter after the master catches brief transients around <span class="mono">‚âà ‚àí6 dBFS</span>.</li>
        <li><b>Soft start/stop</b>: 300 ms fade‚Äëin/out to avoid thumps.</li>
        <li><b>HF pad</b>: automatic <span class="mono">‚àí6 dB</span> padding when <b>Frequency</b> &gt; 10 kHz (badge shows). You can override with ‚ÄúDisable HF pad &gt;10 kHz.‚Äù</li>
        <li><b>Peak monitor + auto‚Äëbackoff</b>: LED + live dBFS readout. If the peak approaches <span class="mono">‚àí1 dBFS</span>, the app reduces output by <span class="mono">3 dB</span> automatically.</li>
        <li><b>Panic stop</b>: press <b>Space</b> or <b>Esc</b> to stop immediately.</li>
        <li><b>Ear routing</b>: Stereo / Left‚Äëonly / Right‚Äëonly so you can favor one ear if your protocol calls for it.</li>
        <li><b>Click‚Äëtrain caution</b>: when <b>Slice</b> is enabled the app shows a headphones warning; keep volumes conservative because gating creates sharper transients.</li>
        <li><b>Session time badge</b>: the header shows <b>Today: X/Y min</b> with color cues and prompts at 75% & 100% of your chosen budget. (Not SPL‚Äëcalibrated.)</li>
      </ul>
      <p class="small">Limitations: the app cannot control your system/device volume and is not a dosimeter. Peak dBFS is not the same as ear‚Äëcanal dB SPL.</p>

      <h3>9) Built‚Äëin Safety Features (what the app enforces)</h3>
      <ul>
        <li><b>Output cap</b>: master output slider is limited to <span class="mono">‚àí24‚Ä¶‚àí6 dBFS</span>. Exports use the same cap.</li>
        <li><b>Limiter</b>: a fast dynamics limiter after the master catches brief transients around <span class="mono">‚âà ‚àí6 dBFS</span>.</li>
        <li><b>Soft start/stop</b>: 300 ms fade‚Äëin/out to avoid thumps.</li>
        <li><b>HF pad</b>: automatic <span class="mono">‚àí6 dB</span> padding when <b>Frequency</b> &gt; 10 kHz (badge shows). You can override with ‚ÄúDisable HF pad &gt;10 kHz.‚Äù</li>
        <li><b>Peak monitor + auto‚Äëbackoff</b>: LED + live dBFS readout. If the peak approaches <span class="mono">‚àí1 dBFS</span>, the app reduces output by <span class="mono">3 dB</span> automatically.</li>
        <li><b>Panic stop</b>: press <b>Space</b> or <b>Esc</b> to stop immediately.</li>
        <li><b>Ear routing</b>: Stereo / Left‚Äëonly / Right‚Äëonly so you can favor one ear if your protocol calls for it.</li>
        <li><b>Click‚Äëtrain caution</b>: when <b>Slice</b> is enabled the app shows a headphones warning; keep volumes conservative because gating creates sharper transients.</li>
        <li><b>Session time badge</b>: the header shows <b>Today: X min</b> so you can tally daily exposure time. (Not SPL‚Äëcalibrated.)</li>
      </ul>
      <p class="small">Limitations: the app cannot control your system/device volume and is not a dosimeter. Peak dBFS is not the same as ear‚Äëcanal dB SPL.</p>
    </div>
  </section>
</div>

<script>
(function(){
  'use strict';
  // Tabs
  const tabAppBtn = document.getElementById('tabAppBtn');
  const tabGuideBtn = document.getElementById('tabGuideBtn');
  const tabApp = document.getElementById('tabApp');
  const tabGuide = document.getElementById('tabGuide');
  function showTab(which){
    const app = which==='app';
    tabApp.classList.toggle('hidden', !app);
    tabGuide.classList.toggle('hidden', app);
    tabAppBtn.classList.toggle('active', app);
    tabGuideBtn.classList.toggle('active', !app);
  }
  tabAppBtn.addEventListener('click', ()=>showTab('app'));
  tabGuideBtn.addEventListener('click', ()=>showTab('guide'));

  const peakLed = document.getElementById('peakLed');
  const peakText = document.getElementById('peakText');
  const todayBadge = document.getElementById('todayBadge');
  const hfPadBadge = document.getElementById('hfPadBadge');
  const hpWarn = document.getElementById('hpWarn');

  // ---------- Helpers ----------
  const lin = (db)=> Math.pow(10, db/20);
  const clamp = (v, lo, hi)=> Math.min(hi, Math.max(lo, v));

  function todayKey(){ const d = new Date(); return d.toISOString().slice(0,10); }
  function getTodayMinutes(){ const key = 'minutes_'+todayKey(); return +(localStorage.getItem(key) || '0'); }
  function addTodayMinutes(min){ const key = 'minutes_'+todayKey(); const cur = getTodayMinutes(); localStorage.setItem(key, String(cur + min)); renderToday(); }
  function renderToday(){ todayBadge.textContent = `Today: ${getTodayMinutes().toFixed(1)} min`; }
  renderToday();

  // Gather globals
  const G = {
    sr: document.getElementById('sr'),
    duration: document.getElementById('duration'),
    mufFc: document.getElementById('mufFc'),
    mufFcNum: document.getElementById('mufFcNum'),
    mufOrder: document.getElementById('mufOrder'),
    mufOrderNum: document.getElementById('mufOrderNum'),
    onMs: document.getElementById('onMs'),
    onMsNum: document.getElementById('onMsNum'),
    offMs: document.getElementById('offMs'),
    offMsNum: document.getElementById('offMsNum'),
    outDb: document.getElementById('outDb'),
    outDbNum: document.getElementById('outDbNum'),
    route: document.getElementById('route'),
    hfOverride: document.getElementById('hfOverride'),
    playToggleBtn: document.getElementById('playToggleBtn'),
    exportBtn: document.getElementById('exportBtn')
  };

  // Layers DOM bundles
  function layerDom(i){
    return {
      enable: document.getElementById(`l${i}_enable`),
      freq: document.getElementById(`l${i}_freq`),
      freqNum: document.getElementById(`l${i}_freqNum`),
      bw: document.getElementById(`l${i}_bw`),
      bwNum: document.getElementById(`l${i}_bwNum`),
      toneMix: document.getElementById(`l${i}_toneMix`),
      toneMixNum: document.getElementById(`l${i}_toneMixNum`),
      noiseMix: document.getElementById(`l${i}_noiseMix`),
      noiseMixNum: document.getElementById(`l${i}_noiseMixNum`),
      level: document.getElementById(`l${i}_level`),
      levelNum: document.getElementById(`l${i}_levelNum`),
      color: document.getElementById(`l${i}_color`),
      amHz: document.getElementById(`l${i}_amHz`),
      amHzNum: document.getElementById(`l${i}_amHzNum`),
      amDepth: document.getElementById(`l${i}_amDepth`),
      amDepthNum: document.getElementById(`l${i}_amDepthNum`)
    };
  }
  const L = [layerDom(1), layerDom(2), layerDom(3)];

  // Link helpers
  function linkPair(rangeEl, numEl, {min=null,max=null}={}){
    const sync = (src,dst)=>{ dst.value = src.value; };
    rangeEl.addEventListener('input', ()=>{ sync(rangeEl, numEl); scheduleApply(); });
    numEl.addEventListener('input', ()=>{
      if(min!==null) numEl.value = Math.max(min, +numEl.value);
      if(max!==null) numEl.value = Math.min(max, +numEl.value);
      sync(numEl, rangeEl); scheduleApply();
    });
    sync(rangeEl, numEl);
  }
  function bindTypingFreq(layer){
    const MIN = 100, MAX = 22000;
    // slider -> number
    layer.freq.addEventListener('input', ()=>{ layer.freqNum.value = layer.freq.value; scheduleApply(); });
    // number typing
    layer.freqNum.addEventListener('input', ()=>{
      const v = parseFloat(layer.freqNum.value);
      if(Number.isFinite(v) && v>=MIN && v<=MAX){ layer.freq.value = String(v); scheduleApply(); }
    });
    const commit = ()=>{
      let v = parseFloat(layer.freqNum.value);
      if(!Number.isFinite(v)) v = +layer.freq.value || 8000;
      v = clamp(v, MIN, MAX);
      layer.freqNum.value = String(v); layer.freq.value = String(v); scheduleApply();
    };
    layer.freqNum.addEventListener('change', commit);
    layer.freqNum.addEventListener('blur', commit);
    layer.freqNum.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ commit(); layer.freqNum.blur(); } });
    layer.freqNum.value = layer.freq.value;
  }

  // Bind all layer controls
  L.forEach(layer=>{
    bindTypingFreq(layer);
    linkPair(layer.bw, layer.bwNum, {min:0, max:20000});
    linkPair(layer.toneMix, layer.toneMixNum, {min:0, max:1});
    linkPair(layer.noiseMix, layer.noiseMixNum, {min:0, max:1});
    linkPair(layer.level, layer.levelNum, {min:0, max:1});
    linkPair(layer.amHz, layer.amHzNum, {min:0, max:40});
    linkPair(layer.amDepth, layer.amDepthNum, {min:0, max:1});
    layer.color.addEventListener('change', scheduleApply);
    layer.enable.addEventListener('change', scheduleApply);
  });

  // Global binds
  linkPair(G.mufOrder, G.mufOrderNum, {min:1, max:8});
  linkPair(G.onMs, G.onMsNum, {min:0, max:200});
  linkPair(G.offMs, G.offMsNum, {min:0, max:500});
  linkPair(G.outDb, G.outDbNum, {min:-24, max:-6});
  // Dedicated binder for muffle cutoff (typing-friendly)
  (function bindMuffle(){
    const MIN=0, MAX=24000;
    G.mufFc.addEventListener('input', ()=>{ G.mufFcNum.value = G.mufFc.value; scheduleApply(); });
    const commit=()=>{
      let v = parseFloat(G.mufFcNum.value); if(!Number.isFinite(v)) v = 6500; v = clamp(v, MIN, MAX);
      G.mufFcNum.value = String(v); G.mufFc.value = String(v); scheduleApply();
    };
    G.mufFcNum.addEventListener('change', commit);
    G.mufFcNum.addEventListener('blur', commit);
    G.mufFcNum.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ commit(); G.mufFcNum.blur(); } });
    G.mufFcNum.value = G.mufFc.value;
  })();
  G.route.addEventListener('change', scheduleApply);
  G.hfOverride.addEventListener('change', scheduleApply);

  function getParams(){
    const layers = L.map((layer)=>{
      const t = +layer.toneMixNum.value, n = +layer.noiseMixNum.value; const s = Math.max(1e-9, t+n);
      return {
        enable: layer.enable.checked,
        freq: Math.max(100, +layer.freqNum.value),
        bw: Math.max(0, +layer.bwNum.value),
        toneMix: t/s, noiseMix: n/s,
        level: clamp(+layer.levelNum.value, 0, 1),
        color: layer.color.value,
        amHz: Math.max(0, +layer.amHzNum.value),
        amDepth: clamp(+layer.amDepthNum.value, 0, 1)
      };
    });
    const anyHigh = layers.some(l => l.enable && l.freq > 10000);
    const hfPadActive = anyHigh && !G.hfOverride.checked;
    hfPadBadge.style.display = hfPadActive ? 'inline-block' : 'none';
    hpWarn.classList.toggle('hidden', !(+G.onMsNum.value > 0));
    return {
      sr: +G.sr.value,
      duration: Math.max(0.1, +G.duration.value),
      layers,
      mufFc: Math.max(0, +G.mufFcNum.value),
      mufOrder: Math.max(1, Math.round(+G.mufOrderNum.value)),
      onMs: Math.max(0, +G.onMsNum.value),
      offMs: Math.max(0, +G.offMsNum.value),
      outDb: Math.min(-6, Math.max(-24, +G.outDbNum.value)),
      route: G.route.value,
      hfPad: hfPadActive ? 0.5 : 1.0
    };
  }

  // ---------- Audio graph builders ----------
  function noiseBuffer(ctx, seconds=2){
    const buf = ctx.createBuffer(1, Math.max(1, Math.floor(ctx.sampleRate * seconds)), ctx.sampleRate);
    const d = buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i] = Math.random()*2-1; return buf;
  }

  function colorNode(ctx, color){
    // Approximate: white = passthrough, pink = gentle high cut, brown = stronger high cut
    if(color === 'white'){
      const g = new GainNode(ctx, {gain:1}); return g;
    }
    if(color === 'pink'){
      const biq = new BiquadFilterNode(ctx, { type:'lowshelf', frequency: 1000, gain: -9 });
      return biq;
    }
    // brown
    const biq = new BiquadFilterNode(ctx, { type:'lowpass', frequency: 1000, Q: 0.707 });
    return biq;
  }

  function buildGraph(ctx, p, forOffline=false){
    const preMuffleMix = new GainNode(ctx, { gain: 1 });

    // Create per-layer sources regardless of enable; we'll zero gains when disabled.
    const layerNodes = [];
    const baseNoise = noiseBuffer(ctx, 2);

    for(let i=0;i<p.layers.length;i++){
      const Lp = p.layers[i];
      // Tone
      const osc = new OscillatorNode(ctx, { type:'sine', frequency: Lp.freq });
      const toneGain = new GainNode(ctx, { gain: Lp.enable ? (Lp.level * Lp.toneMix) : 0 });
      osc.connect(toneGain);

      // Noise -> color -> bandpass -> gain
      const noise = new AudioBufferSourceNode(ctx, { buffer: baseNoise, loop: true });
      const color = colorNode(ctx, Lp.color);
      const bpQ = Math.max(0.0001, Lp.bw>0 ? (Lp.freq/Math.max(1,Lp.bw)) : 0.0001);
      const bp = new BiquadFilterNode(ctx, { type:'bandpass', frequency: Lp.freq, Q: bpQ });
      const noiseGain = new GainNode(ctx, { gain: Lp.enable ? (Lp.level * Lp.noiseMix) : 0 });
      noise.connect(color).connect(bp).connect(noiseGain);

      // Layer sum
      const layerSum = new GainNode(ctx, { gain: 1 });
      toneGain.connect(layerSum); noiseGain.connect(layerSum);

      // AM (amplitude modulation) stage: modulate layerSum -> amGain
      const amGain = new GainNode(ctx, { gain: 1 });
      layerSum.connect(amGain);
      // build mod network even if depth=0 so we can update live
      const amOsc = new OscillatorNode(ctx, { type:'sine', frequency: Math.max(0.0001, Lp.amHz || 0.0001) });
      const amScale = new GainNode(ctx, { gain: (Lp.amDepth||0) / 2 });
      const amOffset = new ConstantSourceNode(ctx, { offset: 1 - (Lp.amDepth||0)/2 });
      amOsc.connect(amScale).connect(amGain.gain);
      amOffset.connect(amGain.gain);
      amOsc.start(); amOffset.start();

      // Feed to pre‚Äëmuffle mix
      amGain.connect(preMuffleMix);

      // start sources
      osc.start(); noise.start();

      layerNodes.push({ osc, toneGain, noise, color, bp, noiseGain, layerSum, amGain, amOsc, amScale, amOffset });
    }

    // Global muffle chain after mixing
    let chainHead = preMuffleMix; const lpChain = [];
    if(p.mufFc > 0){
      for(let i=0;i<p.mufOrder;i++){
        const lp = new BiquadFilterNode(ctx, { type:'lowpass', frequency: p.mufFc, Q: 0.707 });
        chainHead.connect(lp); chainHead = lp; lpChain.push(lp);
      }
    }

    // Global slicing gate
    const gate = new GainNode(ctx, { gain: 1.0 });
    chainHead.connect(gate);
    function scheduleGate(){
      if(p.onMs <= 0){ gate.gain.setValueAtTime(1.0, 0); return; }
      const on = p.onMs / 1000; const off = p.offMs / 1000; const period = Math.max(1e-4, on + off);
      const total = p.duration; let t = 0; gate.gain.cancelScheduledValues(0);
      while(t < total){ gate.gain.setValueAtTime(1.0, t); const tOff = t + on; if(tOff <= total){ gate.gain.setValueAtTime(0.0, tOff); } t += period; }
    }

    // Master + limiter
    const master = new GainNode(ctx, { gain: 0.0 });
    const limiter = new DynamicsCompressorNode(ctx, { threshold: -6, knee: 30, ratio: 20, attack: 0.003, release: 0.25 });
    gate.connect(master).connect(limiter);

    // Routing
    if(forOffline){
      limiter.connect(ctx.destination);
    } else {
      const leftGain = new GainNode(ctx, { gain: 1 });
      const rightGain = new GainNode(ctx, { gain: 1 });
      const merger = new ChannelMergerNode(ctx, { numberOfInputs: 2 });
      limiter.connect(leftGain); limiter.connect(rightGain);
      leftGain.connect(merger, 0, 0); rightGain.connect(merger, 0, 1);
      merger.connect(ctx.destination);
      var routeNodes = { leftGain, rightGain };
    }

    function setMasterTarget(db, pad){ master.gain.setTargetAtTime(Math.max(0, lin(db) * pad), ctx.currentTime, 0.03); }

    function start(at=0){ scheduleGate(); setMasterTarget(p.outDb, p.hfPad); master.gain.setValueAtTime(0.0, at); master.gain.linearRampToValueAtTime(Math.max(0, lin(p.outDb)*p.hfPad), at + 0.3); }
    function stop(at){ try{ master.gain.cancelScheduledValues(at); master.gain.linearRampToValueAtTime(0.0, at + 0.3); for(const ln of layerNodes){ ln.osc.stop(at + 0.35); ln.noise.stop(at + 0.35); } } catch(_){} }

    return { start, stop, nodes: { layerNodes, lpChain, gate, master, limiter, routeNodes } };
  }

  // ---------- Live Playback ----------
  let liveCtx = null; let liveCtrl = null; let liveNodes = null; let liveStopTimer = null; let peakProcessor = null; let sessionStart = null; let tickTimer = null;

  function updatePlayButton(playing){
    const btn = G.playToggleBtn; if(!btn) return;
    if(playing){ btn.textContent = '‚ñ† Stop'; btn.classList.remove('primary'); btn.classList.add('warn'); }
    else { btn.textContent = '‚ñ∂Ô∏é Play / Monitor'; btn.classList.remove('warn'); btn.classList.add('primary'); }
  }

  function setRoute(route){ if(!liveNodes || !liveNodes.routeNodes) return; if(route==='left'){ liveNodes.routeNodes.leftGain.gain.value=1; liveNodes.routeNodes.rightGain.gain.value=0; } else if(route==='right'){ liveNodes.routeNodes.leftGain.gain.value=0; liveNodes.routeNodes.rightGain.gain.value=1; } else { liveNodes.routeNodes.leftGain.gain.value=1; liveNodes.routeNodes.rightGain.gain.value=1; } }

  function updatePeakUI(level){ // level linear 0..1
    const dbfs = 20*Math.log10(Math.max(level,1e-9));
    peakText.textContent = `Peak ${dbfs.toFixed(1)} dBFS`;
    peakLed.classList.remove('green','yellow','red');
    if(level < 0.5) peakLed.classList.add('green');
    else if(level < 0.89) peakLed.classList.add('yellow');
    else peakLed.classList.add('red');
  }

  function attachPeakProcessor(ctx, sourceNode){
    const proc = ctx.createScriptProcessor(2048, 1, 1);
    sourceNode.connect(proc); proc.connect(ctx.destination);
    proc.onaudioprocess = (e)=>{
      const ch = e.inputBuffer.getChannelData(0); let peak = 0; for(let i=0;i<ch.length;i++){ const a=Math.abs(ch[i]); if(a>peak) peak=a; }
      updatePeakUI(peak);
      if(peak >= 0.89){ // ~ -1 dBFS
        const curDb = +G.outDbNum.value; const newDb = Math.max(-24, curDb - 3);
        if(newDb < curDb){ G.outDbNum.value = String(newDb); G.outDb.value = String(newDb); applyLiveParams(); }
      }
    };
    return proc;
  }

  async function play(){
    if(liveCtx){ await stop(); }
    const p = getParams();
    liveCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: p.sr });
    liveCtrl = buildGraph(liveCtx, p);
    liveNodes = liveCtrl.nodes;
    setRoute(p.route);
    peakProcessor = attachPeakProcessor(liveCtx, liveNodes.limiter);
    liveCtrl.start(liveCtx.currentTime);
    updatePlayButton(true);
    sessionStart = performance.now();
    clearTimeout(liveStopTimer); clearInterval(tickTimer);
    liveStopTimer = setTimeout(()=>{ stop(); }, p.duration*1000 + 120);
    tickTimer = setInterval(()=>{ renderToday(); }, 5000);
  }

  async function stop(){
    if(!liveCtx) return;
    try{ const t = liveCtx.currentTime; liveCtrl?.stop(t); }catch(_){ }
    await new Promise(r=>setTimeout(r,380));
    try{ peakProcessor?.disconnect(); }catch(_){ }
    try{ liveCtx.close(); }catch(_){ }
    if(sessionStart){ const mins = (performance.now() - sessionStart)/60000; if(mins>0){ addTodayMinutes(mins); } }
    liveCtx = null; liveCtrl = null; liveNodes = null; peakProcessor = null; sessionStart = null; clearTimeout(liveStopTimer); clearInterval(tickTimer);
    updatePlayButton(false);
  }

  async function togglePlay(){ if(liveCtx){ await stop(); } else { await play(); } }
  G.playToggleBtn.addEventListener('click', togglePlay);

  // Panic stop: Space / Esc
  document.addEventListener('keydown', (e)=>{ if(e.code==='Space' || e.code==='Escape'){ e.preventDefault(); stop(); } });

  // ---------- Live parameter updates ----------
  function applyLiveParams(){ if(!liveCtx || !liveNodes) return; const p = getParams(); try{
    // Per-layer updates
    for(let i=0;i<liveNodes.layerNodes.length;i++){
      const N = liveNodes.layerNodes[i]; const Lp = p.layers[i];
      // Pitch & bandpass
      N.osc.frequency.setTargetAtTime(Lp.freq, liveCtx.currentTime, 0.01);
      N.bp.frequency.setTargetAtTime(Lp.freq, liveCtx.currentTime, 0.01);
      const q = Math.max(0.0001, Lp.bw>0 ? (Lp.freq/Math.max(1,Lp.bw)) : 0.0001);
      N.bp.Q.setTargetAtTime(q, liveCtx.currentTime, 0.01);
      // Mix levels (zero if disabled)
      const tGain = (Lp.enable ? (Lp.level * Lp.toneMix) : 0);
      const nGain = (Lp.enable ? (Lp.level * Lp.noiseMix) : 0);
      N.toneGain.gain.setTargetAtTime(tGain, liveCtx.currentTime, 0.02);
      N.noiseGain.gain.setTargetAtTime(nGain, liveCtx.currentTime, 0.02);
      // Noise color
      if(N.color.type === 'lowshelf'){ N.color.gain.setTargetAtTime((Lp.color==='pink')? -9 : (Lp.color==='brown'? -15 : 0), liveCtx.currentTime, 0.02); }
      if(N.color.type === 'lowpass'){ N.color.frequency.setTargetAtTime((Lp.color==='brown')? 1000 : 20000, liveCtx.currentTime, 0.02); }
      // AM
      const depth = Lp.amDepth || 0; const rate = Math.max(0.0001, Lp.amHz || 0.0001);
      N.amScale.gain.setTargetAtTime(depth/2, liveCtx.currentTime, 0.02);
      N.amOffset.offset.setTargetAtTime(1 - depth/2, liveCtx.currentTime, 0.02);
      N.amOsc.frequency.setTargetAtTime(rate, liveCtx.currentTime, 0.02);
    }
    // Muffle cutoff
    if(liveNodes.lpChain && liveNodes.lpChain.length){ for(const lp of liveNodes.lpChain){ lp.frequency.setTargetAtTime(Math.max(20, p.mufFc || 20000), liveCtx.currentTime, 0.02); } }
    // Master & HF pad
    const target = Math.max(0, lin(p.outDb) * p.hfPad);
    liveNodes.master.gain.setTargetAtTime(target, liveCtx.currentTime, 0.03);
    // Routing
    setRoute(p.route);
  }catch(_){ } }

  let rafPending=false; function scheduleApply(){ if(!liveCtx) return; if(rafPending) return; rafPending=true; requestAnimationFrame(()=>{ rafPending=false; applyLiveParams(); }); }

  // Global inputs that trigger live apply
  [G.mufFc, G.mufFcNum, G.outDb, G.outDbNum, G.route, G.hfOverride].forEach(el=> el.addEventListener('input', scheduleApply));
  // Layer inputs already bound in linkPair/binds call scheduleApply on input
  ;[G.onMs,G.onMsNum,G.mufOrder,G.mufOrderNum,G.duration].forEach(el=> el.addEventListener('input', ()=>{ /* apply on next start */ }));

  // ---------- Export WAV ----------
  function floatToWavBlob(chData, sr){ const numFrames = chData.length; const buffer = new ArrayBuffer(44 + numFrames*2); const view = new DataView(buffer); const writeStr = (o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); }; writeStr(0, 'RIFF'); view.setUint32(4, 36 + numFrames*2, true); writeStr(8, 'WAVE'); writeStr(12,'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true); view.setUint32(24, sr, true); view.setUint32(28, sr*2, true); view.setUint16(32, 2, true); view.setUint16(34, 16, true); writeStr(36,'data'); view.setUint32(40, numFrames*2, true); let offset = 44; for(let i=0;i<numFrames;i++){ const s = Math.max(-1, Math.min(1, chData[i] * 0.98)); view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true); offset += 2; } return new Blob([view], { type:'audio/wav' }); }

  async function exportWav(){
    const p0 = getParams();
    if(p0.duration > 1800){ alert('Please keep duration ‚â§ 1800s (30 min).'); return; }
    const offCtx = new OfflineAudioContext(1, Math.ceil(p0.sr * p0.duration), p0.sr);
    const ctrl = buildGraph(offCtx, p0, true);
    ctrl.start(0);
    const rendered = await offCtx.startRendering();
    const ch = rendered.getChannelData(0);
    let peak=0; for(let i=0;i<ch.length;i++){ const a=Math.abs(ch[i]); if(a>peak) peak=a; }
    if(peak>0.98){ alert('Export peaked too high; lowering output 3 dB and retry.'); G.outDbNum.value = String(Math.max(-24, +G.outDbNum.value - 3)); G.outDb.value = G.outDbNum.value; return exportWav(); }
    const blob = floatToWavBlob(ch, p0.sr);
    // Filename tag
    function layerTag(Lp, idx){ if(!Lp.enable) return `L${idx}off`; return `L${idx}f${Math.round(Lp.freq)}bw${Math.round(Lp.bw)}t${Lp.toneMix.toFixed(2)}n${Lp.noiseMix.toFixed(2)}lvl${Lp.level.toFixed(2)}_${Lp.color}_am${(+Lp.amHz).toFixed(1)}x${(+Lp.amDepth).toFixed(2)}`; }
    const layersPart = p0.layers.map((Lx,i)=>layerTag(Lx,i+1)).join('__');
    const tag = `${layersPart}_muf${Math.round(p0.mufFc)}o${p0.mufOrder}_slice${Math.round(p0.onMs)}x${Math.round(p0.offMs)}_${p0.duration}s_${p0.sr}sr_out${p0.outDb}dB${p0.hfPad<1?'_HFpad':''}`;
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `tinnitus_${tag}.wav`; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 5000);
  }
  G.exportBtn.addEventListener('click', exportWav);
})();
</script>
</body>
</html>
